<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Angui</title>
  
  <subtitle>可知我？</subtitle>
  <link href="https://maritimebyte.github.io/atom.xml" rel="self"/>
  
  <link href="https://maritimebyte.github.io/"/>
  <updated>2024-10-15T18:49:28.462Z</updated>
  <id>https://maritimebyte.github.io/</id>
  
  <author>
    <name>Angui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker compose详解</title>
    <link href="https://maritimebyte.github.io/posts/2222e77d/"/>
    <id>https://maritimebyte.github.io/posts/2222e77d/</id>
    <published>2024-10-15T16:08:37.000Z</published>
    <updated>2024-10-15T18:49:28.462Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-compose 是用于定义和运行多容器 Docker 应用程序的编排工具。使用docker-compose 后不再需要逐一创建和启动容器。您可以使用 YML文件来配置应用程序需要的所有服务，然后使用一个命令，就可以从 YML文件配置中创建并启动所有服务。</p><h2 id="docker-compose.yml配置文件">Docker-compose.yml配置文件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"># 第一部分: Building(构建镜像)</span><br><span class="line">web:</span><br><span class="line">  # 使用当前目录下的Dockerfile</span><br><span class="line">  build: .</span><br><span class="line">  args: # 增加额外参数</span><br><span class="line">    APP_HOME: app</span><br><span class="line">  volumes: # 目录挂载</span><br><span class="line">    - .:/code</span><br><span class="line">  depends_on: # 依赖db和redis</span><br><span class="line">    - db</span><br><span class="line">    - redis</span><br><span class="line">    </span><br><span class="line">  # 使用定制化的Dockerfile，指定新目录相对路径和文件名</span><br><span class="line">  build:</span><br><span class="line">    context: ./dir </span><br><span class="line">    dockerfile: Dockerfile.dev</span><br><span class="line">    container_name: app # 自定义容器名</span><br><span class="line">    </span><br><span class="line">  # 基于现有镜像构建</span><br><span class="line">  image: ubuntu</span><br><span class="line">  image: ubuntu:14.04</span><br><span class="line">  image: remote-registry:4000/postgresql</span><br><span class="line">  image: bcbc65fd</span><br><span class="line">  </span><br><span class="line"># 第二部分: Ports(端口)</span><br><span class="line">  ports: # 指定端口映射，HOST:Container</span><br><span class="line">    - "6379" # 指定容器的端口6379，宿主机会随机映射端口</span><br><span class="line">    - "8080:80"  # 宿主机端口8080，对应容器80</span><br><span class="line"></span><br><span class="line">  # 暴露端口给-link或处于同一网络的容器，不暴露给宿主机。</span><br><span class="line">  expose: ["3000"]</span><br><span class="line">  </span><br><span class="line"># 第三部分: Environment Variables(环境变量)</span><br><span class="line">  environment:</span><br><span class="line">    MODE: development</span><br><span class="line">    SHOW: 'true'</span><br><span class="line">    </span><br><span class="line">  # 等同于</span><br><span class="line">  environment:</span><br><span class="line">    - MODE=development</span><br><span class="line">    - SHOW: 'true'</span><br><span class="line">  </span><br><span class="line">  # 使用环境变量.env文件</span><br><span class="line">  env_file: .env</span><br><span class="line">  env_file:</span><br><span class="line">    - ./common.env</span><br><span class="line">    - ./apps/web.env</span><br><span class="line"></span><br><span class="line"># 第四部分：commands (命令)</span><br><span class="line">  # 容器启动后默认执行命令</span><br><span class="line">  command: bundle exec thin -p 3000</span><br><span class="line">  command: ['/bin/bash/', 'start.sh']</span><br><span class="line"> </span><br><span class="line">  # 容器启动后程序入口</span><br><span class="line">  entrypoint: /code/entrypoint.sh</span><br><span class="line">  </span><br><span class="line"># 第五部分：Networks(网络)</span><br><span class="line">  networks: # 使用bridge驱动创建名为frontend的网络</span><br><span class="line">    frontend:</span><br><span class="line">      driver: bridge</span><br><span class="line">    </span><br><span class="line">    networks: # 使用创建的网络进行通信</span><br><span class="line">      - frontend</span><br><span class="line">      </span><br><span class="line">    # 加入已经存在的外部网络</span><br><span class="line">    networks: </span><br><span class="line">      default:</span><br><span class="line">        external:</span><br><span class="line">          name: my-pre-existing-network</span><br><span class="line"></span><br><span class="line"># 第六部分：Volumes(数据卷)</span><br><span class="line">  volumes: # 创建名为postgres_data的数据卷</span><br><span class="line">    postgres_data:</span><br><span class="line">    </span><br><span class="line">    db:</span><br><span class="line">      image: postgres:latest</span><br><span class="line">      volumes:</span><br><span class="line">        - postgres_data:/var/lib/postgresql/data</span><br><span class="line">      </span><br><span class="line"># 第七部分：External Links(外部链接)</span><br><span class="line"># 目的是让Compose能够连接那些不在docker-compose.yml中定义的单独运行容器</span><br><span class="line">  services:</span><br><span class="line">    web:</span><br><span class="line">      external_links:</span><br><span class="line">        - redis_1</span><br><span class="line">        - project_db_1:mysql</span><br></pre></td></tr></tbody></table></figure><h2 id="docker-compose命令大全">Docker-compose命令大全</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 默认使用docker-compose.yml构建镜像</span><br><span class="line">$ docker-compose build</span><br><span class="line">$ docker-compose build --no-cache # 不带缓存的构建</span><br><span class="line"></span><br><span class="line"># 指定不同yml文件模板用于构建镜像</span><br><span class="line">$ docker-compose build -f docker-compose1.yml</span><br><span class="line"></span><br><span class="line"># 列出Compose文件构建的镜像</span><br><span class="line">$ docker-compose images                          </span><br><span class="line"></span><br><span class="line"># 启动所有编排容器服务</span><br><span class="line">$ docker-compose up -d</span><br><span class="line"></span><br><span class="line"># 查看正在运行中的容器</span><br><span class="line">$ docker-compose ps </span><br><span class="line"></span><br><span class="line"># 查看所有编排容器，包括已停止的容器</span><br><span class="line">$ docker-compose ps -a</span><br><span class="line"></span><br><span class="line"># 进入指定容器执行命令</span><br><span class="line">$ docker-compose exec nginx bash </span><br><span class="line">$ docker-compose exec web python manage.py migrate --noinput</span><br><span class="line"></span><br><span class="line"># 查看web容器的实时日志</span><br><span class="line">$ docker-compose logs -f web</span><br><span class="line"></span><br><span class="line"># 停止所有up命令启动的容器</span><br><span class="line">$ docker-compose down </span><br><span class="line"></span><br><span class="line"># 停止所有up命令启动的容器,并移除数据卷</span><br><span class="line">$ docker-compose down -v</span><br><span class="line"></span><br><span class="line"># 重新启动停止服务的容器</span><br><span class="line">$ docker-compose restart web</span><br><span class="line"></span><br><span class="line"># 暂停web容器</span><br><span class="line">$ docker-compose pause web</span><br><span class="line"></span><br><span class="line"># 恢复web容器</span><br><span class="line">$ docker-compose unpause web</span><br><span class="line"></span><br><span class="line"># 删除web容器，删除前必需停止stop web容器服务</span><br><span class="line">$ docker-compose rm web  </span><br><span class="line"></span><br><span class="line"># 查看各个服务容器内运行的进程 </span><br><span class="line">$ docker-compose top                            </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker-compose 是用于定义和运行多容器 Docker 应用程序的编排工具。使用
docker-compose 后不再需要逐一创建和启动容器。您可以使用 YML
文件来配置应用程序需要的所有服务，然后使用一个命令，就可以从 YML
文件配置中创建并启动所有服务。</summary>
      
    
    
    
    <category term="其他" scheme="https://maritimebyte.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="docker" scheme="https://maritimebyte.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令大全</title>
    <link href="https://maritimebyte.github.io/posts/f38b8ed9/"/>
    <id>https://maritimebyte.github.io/posts/f38b8ed9/</id>
    <published>2024-10-15T16:05:08.000Z</published>
    <updated>2024-10-15T18:49:28.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker镜像操作">Docker镜像操作</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索镜像：docker search + 镜像名字</span></span><br><span class="line">$ docker search nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从registry拉取镜像：docker pull + 镜像名字:版本号</span></span><br><span class="line">$ docker pull nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从registry仓库提交镜像：docker push + 仓库名:标签</span></span><br><span class="line">$ docker push repro1:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地镜像: docker images</span></span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Dockerfile创建镜像: docker build + 目录，.代表当前目录，-t表示加标签</span></span><br><span class="line">$ docker build -t mynginx:1.0 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个或多个镜像: docker rmi + 镜像1 + 镜像2</span></span><br><span class="line">$ docker rmi mynginx:1.0 mynginx:2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除未标记或未用过的镜像</span></span><br><span class="line">$ docker image prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除未使用过的镜像</span></span><br><span class="line">$ docker image prune -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给镜像加标记： docker tag 镜像标签 新镜像标签名</span></span><br><span class="line">$ docker tag mynginx:1.0 nginx1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把镜像保存为.tar文件: docker save 镜像 &gt; 文件</span></span><br><span class="line">$ docker save mynginx:1.0 &gt; mynginx_v1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从.tar文件载入镜像: docker load -i .tar文件</span></span><br><span class="line">$ docker load -i mynginx_v1.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据容器创建镜像：docker commit 容器名 镜像名</span></span><br><span class="line">$ docker commit </span><br></pre></td></tr></tbody></table></figure><h2 id="docker容器操作">Docker容器操作</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器: docker create + 选项(-i, -t, -d, -p, -v, -e) + 镜像</span></span><br><span class="line">$ docker create --name mynginx_1 -it -p 8080:80 mynginx:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各选项含义</span></span><br><span class="line"><span class="comment"># -i:以交互模式运行容器，通常与-t 同时使用；</span></span><br><span class="line"><span class="comment"># -d:后台运行容器，并返回容器ID；</span></span><br><span class="line"><span class="comment"># -p:端口隐射, 宿主机在前，容器在后</span></span><br><span class="line"><span class="comment"># -P:随机映射宿主机端口</span></span><br><span class="line"><span class="comment"># -t:为容器重新分配一个伪输入终端，通常与-i 同时使用；</span></span><br><span class="line"><span class="comment"># -v:目录挂载</span></span><br><span class="line"><span class="comment"># --entrypoint: 指定进入点</span></span><br><span class="line"><span class="comment"># --restart=always: 服务重启</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器：docker start + 容器名</span></span><br><span class="line">$ docker start mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 + 运行容器: docker run + 选项 + 镜像 + 命令</span></span><br><span class="line">$ docker run --name mynginx_1 -it -p 8080:80 mynginx:1.0</span><br><span class="line">$ docker run -it ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行中的容器：docker ps</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器，包括停止运行的容器: docker ps -a</span></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止一个正在运行的容器: docker stop 容器</span></span><br><span class="line">$ docker stop mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器：docker restart + 容器名</span></span><br><span class="line">$ docker restart mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器重命名：docker rename 老名字 新名字</span></span><br><span class="line">$ docker rename mynginx_1 mynginx_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个容器：docker rm 容器名</span></span><br><span class="line">$ docker <span class="built_in">rm</span> mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除一个正在运行的容器：docker rm -f 容器名</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已停止运行的所有容器: docker container prune</span></span><br><span class="line">$ docker container prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件，从容器到宿主机：docker cp 容器名:容器内路径 宿主机文件路径</span></span><br><span class="line">$ docker <span class="built_in">cp</span> myweb_1:/index.html index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件，从宿主机到容器：docker cp 宿主机文件路径 容器名:容器内路径</span></span><br><span class="line">$ docker <span class="built_in">cp</span> index.html myweb_1:/index.html </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入运行的容器，执行命令: docker exec + 选项 + 容器名 + 命令 + 参数</span></span><br><span class="line"><span class="comment"># 推荐大家使用 docker exec命令，使用此命令即使exit容器终端，也不会导致容器的停止</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it mynginx_1 /bin/bash</span><br><span class="line">$ docker <span class="built_in">exec</span> -it mynginx_1 /bin/bash start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器端口映射：docker port 容器名</span></span><br><span class="line">$ docker port mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器内已修改文件：docker diff 容器名</span></span><br><span class="line">$ docker diff mynginx_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志：docker logs + 容器名</span></span><br><span class="line">$ docker logs web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器内运行进程：docker top + 容器名</span></span><br><span class="line">$ docker top web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器的底层信息：docker inspect + 容器名</span></span><br><span class="line">$ docker inspect web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用inspect命令查看容器的IP地址</span></span><br><span class="line">$ docker inspect web | grep <span class="string">"IPAddress"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行容器的统计数据：docker stats</span></span><br><span class="line">$ docker stats</span><br></pre></td></tr></tbody></table></figure><h2 id="dockerfile详解">Dockerfile详解</h2><p>使用<code>$ docker build</code>命令构建镜像时需要用到Dockerfile，它通常会包含如下命令：</p><table><colgroup><col style="width: 7%"><col style="width: 46%"><col style="width: 46%"></colgroup><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td><td>FROM python:3.8.3-alpine</td></tr><tr><td>MAINTAINER</td><td>镜像创建者</td><td>MAINTAINER 大江狗</td></tr><tr><td>COPY</td><td>添加宿主机文件到容器，复制</td><td>COPY . /html/myapp</td></tr><tr><td>ADD</td><td>添加宿主机文件到容器，复制+解压</td><td>ADD myfile.tar /html/myapp</td></tr><tr><td>RUN</td><td>创建镜像时要执行的命令</td><td>RUN pip install -r requirements.txt</td></tr><tr><td>USER</td><td>切换执行后续命令的用户和用户组,但这个用户必需首先已使用RUN的命令进行创建好了。</td><td>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis; USERredis(切换用户)</td></tr><tr><td>WORKDIR</td><td>指定工作目录</td><td>WORKDIR /html/myapp</td></tr><tr><td>CMD</td><td>容器启动时默认要运行的程序。如果执行 docker run后面跟启动命令会被覆盖掉。</td><td>CMD [“/bin/bash”]</td></tr><tr><td>ENV</td><td>设置环境变量</td><td>ENV APP_HOME /html/myapp</td></tr><tr><td>ENTRYPOINT</td><td>同CMD，但其不会被覆盖，可以和dockerrun命令传递的参数进行拼接执行。</td><td>如果设置：ENTRYPOINT [“nginx”, “-c”] ，运行<code>$ docker run mynginx_1 -c /etc/nginx/myweb.conf</code>将默认执行命令：<code>nginx -c /etc/nginx/myweb.conf</code>。</td></tr><tr><td>VOLUME</td><td>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</td><td>VOLUME /tmp</td></tr><tr><td>EXPOSE</td><td>容器暴露端口，供link到当前容器或通过dockernetwork的容器，不会和宿主机端口映射关系。</td><td>EXPOSE 8080</td></tr></tbody></table><h2 id="docker网络操作">Docker网络操作</h2><p>Docker network是主要是用做容器之间的通信，即组建容器之间的局域网，然后加入这个网络的容器可以使用别名(network-alias,比如web, db)或者IP地址进行通信，就如同局域网中主机之间的相互访问。</p><p><strong>备注</strong>：使用<code>-link</code>也可以实现容器之间简单的网络，但是容器较多而且通信关系较为复杂时，使用network就更有条理。除此以外，官方也已经很早不建议使用<code>-link</code>方式进行容器互联，-link未来可能会被删除。</p><h3 id="网络驱动程序">网络驱动程序</h3><p>Docker的网络驱动程序默认情况下有四个：<code>bridge</code>、<code>host</code>、<code>overlay</code>和<code>macvlan</code>，还有一个特殊的网络驱动 none用于禁止容器访问网络。</p><ul><li><code>bridge</code>：默认的网络驱动程序。如果在创建的时候没有指定网络驱动，则默认使用bridge，也就是桥接网络。跟虚拟机的网络地址转换差不多，通过一个内部的子网向容器提供IP 和网络。</li><li><code>host</code>：容器会直接与宿主系统共享 IP地址和网络，但是其它（例如存储，进程命名空间和用户命名空间）相对宿主机隔离的。</li><li><code>overlay</code>：覆盖网络模式可以将不同的Dockerd守护进程连接在一起，该网络模式支持集群容器之间相互通信，以及集群和某个单机版独立容器直接相互通信。该网络模式使用场景比较广泛，通常集群部署时会使用该模式。</li><li><code>macvlan</code>：这个网络驱动有点像虚拟机的桥接模式，它可以让你的容器直接连接到你的物理网络，比如连接到你的路由器，让物理网络来提供IP 地址和网络。</li><li><code>none</code>:禁用容器所有网络。通常与自定义网络驱动程序一起使用。</li></ul><h3 id="创建一个network">创建一个network</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysite1-network是局域网的名字，可以自定义。默认bridge模式。</span></span><br><span class="line">$ docker network create mysite1-network </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用--driver或-d指定使用bridge驱动，创建mysite2-network网络</span></span><br><span class="line">$ docker network create –-driver bridge mysite2-network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已创建的network列表</span></span><br><span class="line">$ docker network <span class="built_in">ls</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络详情</span></span><br><span class="line">$ docker network inspect mysite1-network</span><br></pre></td></tr></tbody></table></figure><h3 id="将容器连接到network">将容器连接到network</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行新的容器，并加入到mysite1-network网络中</span></span><br><span class="line"><span class="comment"># --network 表示这个容器要连接到的网络</span></span><br><span class="line"><span class="comment"># --network-alias 表示这个容器在此网络中的名称，也可以使用--ip来指定容器的ip</span></span><br><span class="line">$ docker run --name=docker-web -d --network=mysite1-network </span><br><span class="line">--network-alias=web docker-web-image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将已经在运行的容器加入网络使用以下命令, 容器名为docker-web，别名为web</span></span><br><span class="line">$ docker network connect --<span class="built_in">alias</span>=web --network=mysite1-network docker-web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接网络时为docker-web容器指定ip地址</span></span><br><span class="line">$ docker network connect --ip=192.10.36.122 multi-host-network docker-web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开docker-web容器与mysite1-network的连接</span></span><br><span class="line">$ docker network disconnet mysite1-network docker-web</span><br></pre></td></tr></tbody></table></figure><h3 id="删除network">删除network</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除mysite1-network网络</span></span><br><span class="line">$ docker network <span class="built_in">rm</span> mysite1-network</span><br></pre></td></tr></tbody></table></figure><h2 id="docker数据卷操作">Docker数据卷操作</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有数据卷</span></span><br><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 使用过滤，列出所有未使用的数据卷</span></span><br><span class="line">$ docker volume <span class="built_in">ls</span> --filter dangling=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 删除一个数据卷</span></span><br><span class="line"><span class="comment"># 容器正在使用的数据卷不能删除，绑定挂载的无法删除。</span></span><br><span class="line">$ docker volume <span class="built_in">rm</span> &lt;volume_name&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="section"></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker镜像操作&quot;&gt;Docker镜像操作&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="其他" scheme="https://maritimebyte.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="docker" scheme="https://maritimebyte.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令大全</title>
    <link href="https://maritimebyte.github.io/posts/44b30305/"/>
    <id>https://maritimebyte.github.io/posts/44b30305/</id>
    <published>2024-10-15T15:59:35.000Z</published>
    <updated>2024-10-15T18:50:35.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件和目录操作">文件和目录操作</h2><h3 id="切换工作目录">切换工作目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home 进入/home目录</span><br><span class="line">cd .. 返回上一级目录</span><br><span class="line">cd ../.. 返回上两级目录</span><br><span class="line">cd ~user1 进入user1的主目录</span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line">pwd 显示当前工作目录</span><br></pre></td></tr></tbody></table></figure><h3 id="查看文件及目录">查看文件及目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ls 查看目录中的文件</span><br><span class="line">ls -F 查看目录中的文件</span><br><span class="line">ls -l 显示文件和目录的详细资料</span><br><span class="line">ls -a 显示隐藏文件</span><br><span class="line">ls *［0-9］* 显示包含数字的文件名和目录名</span><br><span class="line">cat 查看文件内容</span><br><span class="line">more、less  分页显示文本文件内容</span><br><span class="line">head、tail   显示文件头、尾内容</span><br><span class="line">basename 显示文件名或目录名</span><br><span class="line">dirname 显示文件或目录路径。</span><br><span class="line">tree 显示文件和目录由根目录开始的树形结构</span><br></pre></td></tr></tbody></table></figure><h3 id="文件及目录的创建与删除">文件及目录的创建与删除</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">touch 创建空文件</span><br><span class="line">echo 创建带有内容的文件</span><br><span class="line">mkdir dir1 创建dir1目录</span><br><span class="line">mkdir dir1 dir2 同时创建两个目录</span><br><span class="line">mkdir -p /tmp/dir1/dir2 逐级创建多个目录</span><br><span class="line">rm -f file1 删除file1文件，-f强制删除</span><br><span class="line">rmdir dir1 删除dir1空目录</span><br><span class="line">rm -rf dir1 强制删除dir1目录及其子目录及文件，-r表示递归删除</span><br></pre></td></tr></tbody></table></figure><h3 id="文件与目录的移动及复制">文件与目录的移动及复制</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 new_dir 重命名/移动一个目录</span><br><span class="line">cp file1 file2 复制一个文件</span><br><span class="line">cp dir/* . 复制一个目录下的所有文件到当前工作目录</span><br><span class="line">cp -a /tmp/dir1. 复制一个目录到当前工作目录, -a表示所有</span><br><span class="line">ln -s file1 lnk1 创建一个指向文件或目录的软链接</span><br><span class="line">ln file1 lnk1 创建一个指向文件或目录的物理链接</span><br></pre></td></tr></tbody></table></figure><h3 id="文件查找与统计">文件查找与统计</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/下搜索名为file1的文件和目录</span></span><br><span class="line">find / -name file1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/下搜索属于用户user1的文件和目录</span></span><br><span class="line">find / -user user1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在目录/home/user1中搜索带有.bin结尾的文件</span></span><br><span class="line">find /home/user1 -name \*.bin </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索在过去100天内未被使用过的执行文件</span></span><br><span class="line">find /usr/bin -type f -atime +100 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索在10天内被创建或者修改过的文件</span></span><br><span class="line">find /usr/bin -type f -mtime -10 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索以.rpm结尾的文件并定义其权限</span></span><br><span class="line">find / -name \*.rpm -exec chmod 755 ‘{}’ \; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在所有txt文件中查找包含有python的文件。-l表示以列表显示</span></span><br><span class="line">grep -l python *.txt  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找etc及子目录包含python的文件，-i表示不区分大小写，-R表示递归</span></span><br><span class="line">grep -iR python /etc/* </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">寻找以.ps结尾的文件</span> </span><br><span class="line">locate \*.ps </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示一个二进制文件、源码或man的位置,比如bash命令</span></span><br><span class="line">whereis bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示一个二进制文件或可执行文件(比如bash)的完整路径</span></span><br><span class="line">which bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计text.txt中行数、字数、字符数</span></span><br><span class="line">wc test.txt </span><br></pre></td></tr></tbody></table></figure><h2 id="用户群组和权限">用户、群组和权限</h2><h3 id="群组的创建与删除">群组的创建与删除</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd group_name 创建一个新用户组</span><br><span class="line">groupdel group_name 删除一个用户组</span><br><span class="line">groupmod -n new_group old_group 重命名一个用户组</span><br><span class="line">newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</span><br></pre></td></tr></tbody></table></figure><h3 id="用户的管理">用户的管理</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">useradd user1 创建一个新用户，可结合如下选项使用：</span><br><span class="line">    -u 指定用户的UID</span><br><span class="line">    -g 指定用户所属的群组</span><br><span class="line">    -d 指定用户的home目录</span><br><span class="line">    -c 指定用户的备注信息</span><br><span class="line">    -s 指定用户所用的shell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改用户属性</span></span><br><span class="line">usermod -c “FTP User” -g system -d /ftp/user1 -s /bin/nologin user1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个用户</span></span><br><span class="line">userdel user1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码管理</span></span><br><span class="line">passwd 修改口令</span><br><span class="line">passwd user1 修改一个用户的口令 （只允许root执行）</span><br><span class="line">change -E 2020-12-31 user1 设置用户口令的失效期限</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户切换</span></span><br><span class="line">id 查看用户的uid,gid及归属的用户组。</span><br><span class="line">su 切换用户身份。</span><br><span class="line">visudo 编辑/etc/sudoers文件的专属命令。</span><br><span class="line">sudo 以另外一个用户身份（默认root用户）执行事先在sudoers文件允许的命令。</span><br></pre></td></tr></tbody></table></figure><h3 id="权限的分配">权限的分配</h3><p>主要有两个命令：<code>chmod</code>是用来设置文件夹和文件权限，<code>chown</code>是用来设置用户组。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示权限</span></span><br><span class="line">ls -lh </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加目录的所有人（u）、群组（g）以及其他人（o）读、写和执行的权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r, w, x分别代表读、写和执行</span></span><br><span class="line">chmod ugo+rwx directory1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除群组（g）与其他人（o）对目录的读写执行权限，</span></span><br><span class="line">chmod go-rwx directory1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件aaa.sh可执行权限,+ 代表增加权限，-代表移除权限</span></span><br><span class="line">chmod +x aaa.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件file1设置可读、可写和可执行的权限(r=4,w=2,x=1)</span></span><br><span class="line">chmod 777 file1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改变一个文件的所有人属性</span></span><br><span class="line">chown user1 file1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改变一个目录的所有人属性并同时改变改目录下所有文件的属性</span></span><br><span class="line">chown -R user1 directory1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改变文件的群组</span></span><br><span class="line">chgrp group1 file1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改变一个文件的所有人和群组属性</span></span><br><span class="line">chown user1:group1 file1 </span><br></pre></td></tr></tbody></table></figure><h2 id="系统管理命令">系统管理命令</h2><p>系统管理命令中最重要的是服务器性能监控命令和进程管理命令，尤其是监控CPU和当前负载信息的<code>uptime</code>,监控内存使用情况的 <code>free</code>, 监控磁盘使用情况的<code>df</code>, 以管理进程的<code>top</code>, <code>ps</code>和<code>kill</code>命令。</p><h3 id="基础命令">基础命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">who   显示在线登陆用户</span><br><span class="line">whoami   显示当前操作用户</span><br><span class="line">hostname   显示主机名</span><br><span class="line">uname   显示系统信息</span><br><span class="line">clear   清屏</span><br><span class="line">alias   对命令重命名 如：alias showmeit="ps -aux" ，另外解除使用unaliax showmeit</span><br><span class="line">ifconfig 查看网络情况</span><br><span class="line">ping 测试网络连通</span><br></pre></td></tr></tbody></table></figure><h3 id="性能监控">性能监控</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chkconfig 管理Linux系统开机启动项</span><br><span class="line">uptime 获取CPU运行时间和查询Linux系统负载等信息</span><br><span class="line">free 监控内存及交换分区的使用</span><br><span class="line">sar 全面地获取系统的CPU、运行队列、磁盘 I/O、内存和网络等性能数据。</span><br><span class="line">df 查看磁盘使用情况 df -h 带有单位显示磁盘信息</span><br><span class="line">netstat 显示网络状态信息，netstat -t可查看tcp连接</span><br><span class="line">vmstat 虚拟内存统计</span><br><span class="line">mpstat 显示各个可用CPU的状态统计</span><br><span class="line">du 查看目录大小 du -h /home带有单位显示目录信息</span><br><span class="line">iostat 统计系统IO</span><br></pre></td></tr></tbody></table></figure><h3 id="进程管理">进程管理</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top 动态显示当前耗费资源最多进程信息</span><br><span class="line">  - P: CPU 占用率大小的顺序排列进程列表  </span><br><span class="line">  - M: 以内存占用率大小的顺序排列进程列表  </span><br><span class="line">ps 显示瞬间进程状态 </span><br><span class="line">ps -aux 全格式显示进程信息,BSD风格</span><br><span class="line">ps -ef 全格式显示进程信息,System V风格</span><br><span class="line">kill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</span><br><span class="line">killall 通过进程名终止进程</span><br></pre></td></tr></tbody></table></figure><h3 id="开机关机与注销">开机、关机与注销</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h hours:minutes &amp; 按预定时间关闭系统 </span><br><span class="line">shutdown -c 取消按预定时间关闭系统 </span><br><span class="line">shutdown -r now 重启</span><br><span class="line">reboot重启</span><br><span class="line">poweroff 关闭电源。</span><br><span class="line">logout 注销。</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件和目录操作&quot;&gt;文件和目录操作&lt;/h2&gt;
&lt;h3 id=&quot;切换工作目录&quot;&gt;切换工作目录&lt;/h3&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="后端" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="linux" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/linux/"/>
    
    
    <category term="linux" scheme="https://maritimebyte.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://maritimebyte.github.io/posts/f5f9fa9b/"/>
    <id>https://maritimebyte.github.io/posts/f5f9fa9b/</id>
    <published>2024-10-15T14:50:58.000Z</published>
    <updated>2024-10-15T18:49:28.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker">Docker</h2><h3 id="docker是什么">Docker是什么</h3><p>Docker是一个用于构建，运行，传送的平台，<em>是一个开源的应用容器引擎</em>，Docker能将配置文件、启动命令、应用程序、环境变量、第三方软件库和依赖包、运行时环境、操作系统的等一系列软件所需要的条件打包在一起，方便其在任何环境中运行。</p><h3 id="docker为什么存在">Docker为什么存在</h3><p>Docker的出现旨在解决开发人员在开发和部署时的繁杂的调试配置问题，Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，提高开发者或者企业对于软件的开发效率。</p><h3 id="docker和虚拟机的区别">Docker和虚拟机的区别</h3><p>Docker容器与虚拟机很相似，但它们之间又有着很大的区别。</p><p>虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。创建虚拟机时，会将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存，每个虚拟机都有独立的硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。</p><p>虚拟机会消耗大量系统资源和开销，尤其是当多个虚拟机在同一物理服务器上运行时，每个虚拟机都有自己的子操作系统，大量精力以及资源被用于虚拟化的部署和运行上。</p><p>容器类似于虚拟机，只是容器不是完整的操作系统，容器通常只包含必要的操作系统包和应用程序，这就是它们轻量级的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;
&lt;h3 id=&quot;docker是什么&quot;&gt;Docker是什么&lt;/h3&gt;
&lt;p&gt;Docker是一个用于构建，运行，传送的平台，&lt;em&gt;是一个开源的应用容器引擎&lt;/em&gt;，Docker能将配置文件、启动命令、应用程序、环境变量、第三</summary>
      
    
    
    
    <category term="其他" scheme="https://maritimebyte.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="docker" scheme="https://maritimebyte.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>学习的一些思考</title>
    <link href="https://maritimebyte.github.io/posts/3d85f60/"/>
    <id>https://maritimebyte.github.io/posts/3d85f60/</id>
    <published>2024-10-15T14:16:16.000Z</published>
    <updated>2024-10-15T18:49:28.472Z</updated>
    
    <content type="html"><![CDATA[<p>在学习的过程中，我经常会感觉为什么自己总是在重复的学习某种概念和定义，一旦在需要使用它们时，但又好像不知道如何使用，下面是我最近在学习一些新知识的一些思考，仅代表个人的观点，旨在帮助自己提高学习的效率，如果您有更好的想法，可以在评论区告诉我</p><h2 id="概念意义关系">概念，意义，关系</h2><p>我们在学习的过程中，总是非常的注重一个知识点的概念和定义，而忽视了它存在的意义，以及和其他相关的关联性。</p><p>在我看来，一件事物的概念通俗来说就是回答“它是什么？”，我们需要语言把事物抽象出来描述，对它做一个定义，方便我们在以后遇到类似的事物做一个归类。</p><p>意义则指的是“为什么？”，它为什么存在，因为什么事情存在，或者说是为了解决什么其他的问题而存在，只有了解了“为什么？”，才能知道如何去使用这个我们内化的知识点或者技术。</p><p>关系则是这个事物的在一个“位置”，我们总是觉得学过的知识点是碎片化的，这和我们不知道它的位置很重要，很多时候，知识也好，技术也罢，它们是成体系化，几乎不会单独的存在，如果对一个系统性知识没有在脑海里构建出体系化、结构化，不仅不利于我们记忆，而且容易丢失，导致我们在一段时间后，对它有出现陌生感。</p><blockquote><p>举个例子：我们要想认识了解一个人，我们得知道“他是谁？怎么样？”，需要了解他的外貌、性格、社会地位等。而“为什么”，则指的是分析他如何成为了这么一个人？比方说什么样环境，什么样的事情可能导致了他变成这么一个人，这有利于我们去思考他的行为和动机。而“关系”则指得是他的一些关系，他和谁相关，他认识那些人，或者别人对他的一些评价，有助于我们记住他，以及他所在的一个群体或者层次。</p></blockquote><h2 id="学习的方法">学习的方法</h2><p>在现在的环境中，尤其是脱离了学习的环境之后，再也很难找到充裕的世界系统性学习一个体系化的知识点，大部分时候我们都只能在碎片化的时间里去吸收新的事物。那么再像再以学生的思维去学习，那么必定会觉得很难再把知识点学进去，因此好的学习方法十分地重要。</p><p>我以为，碎片化的时间尤其锻炼一个人对体系化知识点的拆解吸收能力，也就是说，我们不能在盲目的崇拜“大而全”，而是要把知识切割，做到”小而精“，做到”分而治之“。</p><p>通常来说，规划<strong>Todo</strong>是个很好的方法，但是在实际过程中，我经常不能完成，因为<strong>Todo</strong>是线性的，我们经常只是简单的把一件事拆解成好几个时间段去做，但是这难免会产生枯燥感，最好的方法是借助脑图，把好几件时间拆分开来，并规划好进度，这样在一段时间后，反而能做到有始有终，缺点是学习完成之后，我们还需要把知识带你串联起来，好处也是明显，串联知识点的过程也是一个回顾复习的过程，有利于我们加深记忆。</p><hr><p>...</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习的过程中，我经常会感觉为什么自己总是在重复的学习某种概念和定义，一旦在需要使用它们时，但又好像不知道如何使用，下面是我最近在学习一些新知识的一些思考，仅代表个人的观点，旨在帮助自己提高学习的效率，如果您有更好的想法，可以在评论区告诉我&lt;/p&gt;
&lt;h2 id=&quot;概念意义</summary>
      
    
    
    
    <category term="其他" scheme="https://maritimebyte.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的常用命令</title>
    <link href="https://maritimebyte.github.io/posts/4ad0b8cc/"/>
    <id>https://maritimebyte.github.io/posts/4ad0b8cc/</id>
    <published>2024-10-15T00:10:32.000Z</published>
    <updated>2024-10-15T18:49:28.470Z</updated>
    
    <content type="html"><![CDATA[<p>linux系统拥有很多的命令，用来执行各种任务，本文主要介绍一些linux的常用命令</p><h2 id="ls命令">ls命令</h2><p>ls（list）命令是用来显示当前目录下的内容</p><p>ls [-a -l -t -h-r]：显示隐藏，列表显示，修改时间排序，人类可读文件大小显示，逆序排序</p><h2 id="ln命令">ln命令</h2><p>ln（link）创建链接文件</p><p>ln [-s] 目标文件 链接文件：默认创建硬链接文件，创建软连接文件</p><p>软连接和硬链接的区别</p><p>软连接相当于windows的快捷方式</p><p>硬链接创建的文件相当于量子纠缠文件，它们指向同一个inode（indexnode），共享文件类型，权限，所有者，文件大小，时间戳，数据块指针，它们相当于一组数据的不同名称</p><h2 id="chmod命令">chmod命令</h2><p>chmod用于改变文件的权限</p><p>chmod +(-) r(w,x)文件名：添加（或删除）文件的只读（写入，执行）权限</p><p>r：4，w：2，x：1</p><p>chmod 777 文件名：给予所有用户所有权限</p><h2 id="touch命令">touch命令</h2><p>用于更新文件修改时间</p><p>touch 文件名：更新文件修改时间，不存在文件，则创建</p><h2 id="echo命令">echo命令</h2><p>echo用于输出文本</p><p>echo “文本内容”：回显文本内容</p><p>echo “文本内容” &gt;文件名：将文本内容重定向到文件，当文件不存在时，会新建该文件</p><h2 id="cat命令">cat命令</h2><p>cat命令用于输出文件内容</p><p>cat 文件名：输出文件内容</p><h2 id="cd和pwd命令">cd和pwd命令</h2><p>cd用于切换目录</p><p>pwd由于显示但前目录</p><blockquote><p>/ 根目录</p><p>/bin 用户二进制文件 /opt 可选第三方软件包</p><p>/sbin 系统二进制文件 /tmp 临时文件</p><p>/etc 配置文件 /usr 用户程序</p><p>/dev 设备文件 /var 可变文件如日志等</p><p>/home 用户家目录 /boot 启动加载器文件</p><p>/root root用户家目录 /proc 进程信息</p><p>/lib 系统库文件 /sys 系统文件</p></blockquote><h2 id="cp命令">cp命令</h2><p>cp（copy）命令用于复制文件</p><p>cp 目标文件名 新文件名：将目标文件复制到新文件</p><p>cp -r 目标目录 新目录名：将目标目录所有文件复制到新目录下</p><h2 id="mv命令">mv命令</h2><p>mv（move）命令用于移动文件</p><p>mv 目标文件名新文件名：移动目标文件并改为新文件名，如果目标文件和新文件所在目录相同，则实现重命名操作</p><h2 id="mkdir命令">mkdir命令</h2><p>mkdir用于创建目录</p><p>mkdir [-p]目录名：创建目录，-p表示创建多级目录，否则只能在当前目录生成子目录</p><h2 id="du命令">du命令</h2><p>du（dis usage）命令查看文件大小</p><p>du [-h]</p><p>也可用于查看文件目录结构，可加上-h表示用人性化的方式显示</p><h2 id="tree命令非自带">tree命令（非自带）</h2><p>需要用包管理器安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install tree</span><br></pre></td></tr></tbody></table></figure><p>tree命令用于显示目录结构</p><h2 id="rm命令">rm命令</h2><p>rm命令用于删除文件或目录</p><p>rm [-r] 文件名或目录名：删除文件或目录，删除目录时需要加上-r</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;linux系统拥有很多的命令，用来执行各种任务，本文主要介绍一些linux的常用命令&lt;/p&gt;
&lt;h2 id=&quot;ls命令&quot;&gt;ls命令&lt;/h2&gt;
&lt;p&gt;ls（list）命令是用来显示当前目录下的内容&lt;/p&gt;
&lt;p&gt;ls [-a -l -t -h
-r]：显示隐藏，列表显示，修改</summary>
      
    
    
    
    <category term="后端" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="linux" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/linux/"/>
    
    
    <category term="linux" scheme="https://maritimebyte.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo SEO</title>
    <link href="https://maritimebyte.github.io/posts/1f62d2d5/"/>
    <id>https://maritimebyte.github.io/posts/1f62d2d5/</id>
    <published>2024-10-14T23:01:27.000Z</published>
    <updated>2024-10-14T23:40:29.702Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建hexo博客后，如果想要提高我们博客的搜索量，需要做一些优化搜索引擎的工作，以便我们的博客获得更高的曝光量</p><h2 id="将网站链接提交到百度">将网站链接提交到百度</h2><p><a href="https://www.sousuoyinqingtijiao.com/baidu/tijiao/">百度搜索引擎提交入口</a></p><p>有三种验证方式，选择HTML方式，将其添加到主题的<code>head.swing</code>文件中</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"baidu-site-verification"</span> <span class="attr">content</span>=<span class="string">"code-iqJOekpmDl"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="给站点添加sitemap">给站点添加sitemap</h2><ol type="1"><li><p>Hexo安装sitemap</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save <span class="comment">#sitemap.xml适合提交给谷歌搜素引擎</span></span><br><span class="line">npm install hexo-generator-baidu-sitemap --save <span class="comment">#baidusitemap.xml适合提交百度搜索引擎</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在站点配置文件<code>_config.yml</code>中添加代码</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>修改站点配置<code>_config.yml</code></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Hexo编译</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></tbody></table></figure><p>会在<code>/public</code>目录下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code></p></li><li><p>提交sitemap到站长平台</p><p>百度站长平台sitemap提交是邀请制，并没有对所有站长开发，只有网站到一定等级百度才会在你后台开放sitemap到入口</p></li></ol><h2 id="添加蜘蛛协议">添加蜘蛛协议</h2><ol type="1"><li><p>新建robots.txt文件，添加一下内容，把robot.txt放在hexo站点的souce文件下</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://zsyyblog.com/sitemap.xml</span><br><span class="line">Sitemap: https://zsyyblog.com/baidusitemap.xml</span><br></pre></td></tr></tbody></table></figure></li><li><p>在百度站长平台监测并更新robots</p><p>提示检测到您更新了robots文件即成功</p></li></ol><h2 id="给出站链接添加nofollow标签">给出站链接添加”nofollow“标签</h2><p><code>nofollow</code>标签谷歌领头创新的一个“反垃圾链接”标签，并被百度、yahoo等各大搜索引擎广泛支持，应用<code>nofollow</code>标签的目的是：用于指示搜索引擎不要抓取网页上带有<code>nofollow</code>属性的任何出站链接，以减少垃圾链接的分散网络权重</p><p>以Hexo的NexT主题为例，需要修改两处</p><ol type="1"><li><p>找到footer.swig，作一下修改</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{{ __('footer.powered', '<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"http://hexo.io"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>') }}</span><br><span class="line">改成</span><br><span class="line">{{ __('footer.powered', '<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"http://hexo.io"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>') }}</span><br><span class="line"></span><br><span class="line">将下面代码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span>&gt;</span></span><br><span class="line">改成</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>修改sidebar.swig</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"{{ link }}"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>{{ name }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">改成</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"{{ link }}"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span>{{ name }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">将下面代码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0"</span> <span class="attr">class</span>=<span class="string">"cc-opacity"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">改成</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0"</span> <span class="attr">class</span>=<span class="string">"cc-opacity"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用chinaz站长工具进行各项检测</p></li></ol><h2 id="keywords和description">keywords和description</h2><p>在<code>/scaffolds/post.md</code>中添加如下代码，用于生成文章的关键字和描述</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keywords: </span><br><span class="line">description:</span><br></pre></td></tr></tbody></table></figure><p>在<code>head.swig</code>有如下代码，用于生成文章keywords。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{% if page.keywords %}</span><br><span class="line">  &lt;meta name="keywords" content="{{ page.keywords }}" /&gt;</span><br><span class="line">{% elif page.tags and page.tags.length %}</span><br><span class="line">  &lt;meta name="keywords" content="{% for tag in page.tags %}{{ tag.name }},{% endfor %}" /&gt;</span><br><span class="line">{% elif theme.keywords %}</span><br><span class="line">  &lt;meta name="keywords" content="{{ theme.keywords }}" /&gt;</span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure><p>在post.swig中找到</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{% if post.description %}</span><br><span class="line">将以下代码去掉：</span><br><span class="line">{% if post.description %}</span><br><span class="line">  {{ post.description }}</span><br><span class="line">  &lt;div class="post-more-link text-center"&gt;</span><br><span class="line">    &lt;a class="btn" href="{{ url_for(post.path) }}"&gt;</span><br><span class="line">      {{ __('post.read_more') }} &amp;raquo;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>否则首页文章摘要就会变成文章的description</p><h2 id="首页title优化">首页title优化</h2><p>更改<code>index.swig</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{% block title %} {{ config.title }} {% endblock %}</span><br><span class="line">改成</span><br><span class="line">{% block title %} {{ config.title }} - {{ theme.description }} {% endblock %}</span><br></pre></td></tr></tbody></table></figure><p>这会使你的首页标题更加符合网站名称-网站描述这习惯</p><h2 id="修改文章链接">修改文章链接</h2><p>Hexo默认文章链接形式为<code>domain/year/month/day/postname</code>，默认是一个斯基url，并且可能造成url过长，对搜索引擎十分不友好，我们可以改成<code>domain/postname</code>形式</p><p>编辑站点<code>_config.yml</code>文件，修改其中的<code>permalink</code>字段改为<code>permalink::title.html</code>即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在搭建hexo博客后，如果想要提高我们博客的搜索量，需要做一些优化搜索引擎的工作，以便我们的博客获得更高的曝光量&lt;/p&gt;
&lt;h2 id=&quot;将网站链接提交到百度&quot;&gt;将网站链接提交到百度&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sousuoyinqingtij</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vim常用命令</title>
    <link href="https://maritimebyte.github.io/posts/8c31560b/"/>
    <id>https://maritimebyte.github.io/posts/8c31560b/</id>
    <published>2024-10-14T21:18:20.000Z</published>
    <updated>2024-10-14T23:47:22.460Z</updated>
    
    <content type="html"><![CDATA[<p>vim是一款文本编辑器</p><p>最开始的开发只是为了复制vi的功能，后来发展成为vi的改良版本</p><p>作为一款好用的文本编辑器在程序员中广泛使用，尤其被unix系统用户喜爱</p><h2 id="vim模式">vim模式</h2><h3 id="命令模式">命令模式</h3><p><strong>进入命令模式</strong>：输入i，a，o；I，A，O</p><p>i，a：光标前后</p><p>I，A：当前行首和末</p><p>o，O：当前行行上下行</p><p><strong>进入尾行模式</strong>：输入：</p><p><strong>撤销和重做</strong>：u和ctrl+r</p><hr><h4 id="控制光标">控制光标</h4><p>H，J，K，L分别控制光标左，上，下，右</p><p>nH：当前光标向左移动n次（J，K，L同理）</p><p>^，$移动光标到行首行尾</p><p>gg，G移动光标到文本首和尾</p><p>nG：移动到n行（等同于在<strong>尾行模式</strong>下输入：n+回车）</p><p>ctrl+f：下一页</p><p>ctrl+b：上一页</p><p>ctrl+u：上一面</p><p>ctrl+d：下一面</p><hr><h4 id="剪贴板操作">剪贴板操作</h4><p>dd，yy，p：剪切，复制，粘贴当前行</p><blockquote><p>Tips：前面可加数字n表示重复几次</p></blockquote><h3 id="插入模式">插入模式</h3><p><strong>退出插入模式</strong>：ESC</p><h3 id="尾行模式">尾行模式</h3><p><strong>退出尾行模式</strong>：回车或者ESC</p><h4 id="查找和替换">查找和替换</h4><p>/，？：向上和向下查找</p><blockquote><p>[n1,n2]s/（被替换的内容）/（要替换的内容）/[g]</p><p>[n1,n2]表示范围，不写默认当前行；[g]表示全局替换，不写默认只替换每行第一个内容</p></blockquote><h3 id="其他模式">其他模式</h3><p>替换模式和可视模式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vim是一款文本编辑器&lt;/p&gt;
&lt;p&gt;最开始的开发只是为了复制vi的功能，后来发展成为vi的改良版本&lt;/p&gt;
&lt;p&gt;作为一款好用的文本编辑器在程序员中广泛使用，尤其被unix系统用户喜爱&lt;/p&gt;
&lt;h2 id=&quot;vim模式&quot;&gt;vim模式&lt;/h2&gt;
&lt;h3 id=&quot;命令模式&quot;</summary>
      
    
    
    
    <category term="后端" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="linux" scheme="https://maritimebyte.github.io/categories/%E5%90%8E%E7%AB%AF/linux/"/>
    
    
    <category term="linux" scheme="https://maritimebyte.github.io/tags/linux/"/>
    
    <category term="vim" scheme="https://maritimebyte.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Mac上运行Pkhex</title>
    <link href="https://maritimebyte.github.io/posts/299de451/"/>
    <id>https://maritimebyte.github.io/posts/299de451/</id>
    <published>2024-10-10T13:42:20.000Z</published>
    <updated>2024-10-14T23:47:38.070Z</updated>
    
    <content type="html"><![CDATA[<p>对于宝可梦玩家来说，使用魔法来调整宠物的属性几乎是必须的（除非你浑身是肝，或者你只是一个pve玩家），Pkhex因为是基于<code>.NET</code>开发，所以在Windows上使用它是十分方便的，但是在Linux以及mac则需要借助wine，因为我使用的是mac系统，下面将介绍如何在mac上使用pkhex。</p><h2 id="安装xquartz">安装XQuartz</h2><p><a href="https://www.xquartz.org/">xquartz</a>是wine的依赖，想要安装wine，它是必须的。</p><h2 id="安装wine">安装wine</h2><p>下载<a href="https://dl.winehq.org/wine-builds/macosx/download.html">WineDevelopment</a>应用程序</p><h2 id="安装最新版.net">安装最新版.NET</h2><p>下载最新版本的<a href="https://dotnet.microsoft.com/en-us/download/dotnet/8.0">.NET</a>，右键单击文件，转到“打开方式...”并选择Wine Devel</p><blockquote><p>tip: 强烈建议将打开 .exe 文件的应用程序更改为 Wine Devel。右键单击&gt; 获取信息 &gt; 打开方式 - 并从弹出列表中选择“Wine Devel”</p><p>如果 Wine Devel 呈灰色，请取消勾选“推荐应用”并选择 WineDevel。从现在起，任何 .exe 文件都将自动使用 Wine Devel 打开</p></blockquote><h2 id="使用pkhex">使用Pkhex</h2><p>下载<a href="https://projectpokemon.org/home/files/file/2774-pkhex-for-mac/">PKHeXfor Mac</a>并将其拖到您的应用程序文件夹并打开</p><p>大功告成🎉</p><h2 id="后记">后记</h2><p>其他使用修改Pkhex的方法</p><p><a href="https://github.com/arleypadua/PKHeX.CLI/releases">只需在此处</a>下载适用于 Linux 的工件，解压缩并在控制台中运行命令 pkhex-cli</p><blockquote><p>了解更多信息，这是带有自述文件的项目源代码</p><p>https://github.com/arleypadua/PKHeX.CLI</p></blockquote><p>基于网络的版本：</p><p><a href="https://pkhex-web.github.io/">https://pkhex-web.github.io</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于宝可梦玩家来说，使用魔法来调整宠物的属性几乎是必须的（除非你浑身是肝，或者你只是一个pve玩家），Pkhex因为是基于&lt;code&gt;.NET&lt;/code&gt;开发，所以在Windows上使用它是十分方便的，但是在Linux以及mac则需要借助wine，因为我使用的是mac系统</summary>
      
    
    
    
    <category term="未分类" scheme="https://maritimebyte.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+Butterfly增加文章双栏布局</title>
    <link href="https://maritimebyte.github.io/posts/9f9978a1/"/>
    <id>https://maritimebyte.github.io/posts/9f9978a1/</id>
    <published>2024-10-09T05:13:25.000Z</published>
    <updated>2024-10-13T19:33:43.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件">安装插件</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-butterfly-article-double-row --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line">cnpm i hexo-butterfly-article-double-row --save</span><br></pre></td></tr></tbody></table></figure><h2 id="修改站点配置">修改站点配置</h2><p>修改站点根目录下的配置文件<code>_config.yml</code></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">butterfly_article_double_row:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="部署">部署</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>查看效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装插件&quot;&gt;安装插件&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客底层原理</title>
    <link href="https://maritimebyte.github.io/posts/d24d3c28/"/>
    <id>https://maritimebyte.github.io/posts/d24d3c28/</id>
    <published>2024-10-09T04:43:22.000Z</published>
    <updated>2024-10-09T05:11:17.630Z</updated>
    
    <content type="html"><![CDATA[<p>在B站通过up主程序羊了解到了Hexo，并且通过视频教程一步步搭建了个人博客，逞着兴趣正浓，网上看了许多关于Hexo的有关资料，对Hexo有了更多的了解。</p><blockquote><p>Hexo的优缺点</p></blockquote><p>优点：</p><ul><li>生态丰富，主题多</li><li>相关文档多，解决bug有优势</li><li>通过修改yaml配置文件修改样式简单</li></ul><p>缺点：</p><ul><li>初次配置会遇到很多bug，对新生和非专业人员不友好</li><li>每次发布文章都需要重新部署，没有后台管理系统</li></ul><p>相当一部分Hexo是搭建在LNMP或LAMP环境下，LNMP指linux+nginx+mysql+php,这是一款非常强大的环境套件，nginx以其轻量而高效受到建站者青睐。</p><h2 id="github-page">Github page</h2><p>Hexo搭建的博客项目源码托管在github，并享受github pages服务。</p><p>GitHubpages简称pages服务，每个仓库都有一个pages服务，可用来展示项目，通过简单的设置项目的index.html，并以此做为入口供用户参观访问。可是一个相当实用的功能呀！大部分的pages服务都是用来搭建个人博客的。言外之意不仅能搭建博客，还能做些其他的事情~</p><p>为什么需要Pages技术</p><p>生成博客的页面有动、静态页面之分</p><p>著名的博客 wordpress ，既是动态页面生成的博客，其思路是php+Mysql</p><p>博客hexo生成的是静态页面，而Githubpages又支持静态页面的解析。因此二者一拍即合能够用来生成html拼合成博客。</p><blockquote><p>静态页面意味着评论、分享功能依赖第三方插件，但它带来的轻量、高效是动态页面不及的！</p></blockquote><h2 id="hexo">Hexo</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/12/1a5437eb122fc14fc88b1920aed5dcca~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="hexo官网">hexo官网</p><p>在 Hexo 的官网，我们可以直观的看到对 Hexo的介绍：<strong>快速、简洁且高效的博客框架</strong></p><p>在 Hexo 的文档中，我们可以找到官方对 Hexo 的定义：</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>在官方文档中安装了 Hexo 中我们就安装了Hexo，然后我们就可以看到文档结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml      // 站点配置文件</span><br><span class="line">├── db.json          // 缓存文件</span><br><span class="line">├── node_modules     // 安装的插件以及hexo所需的一些nodejs模块</span><br><span class="line">├── package.json     // 项目的依赖文件</span><br><span class="line">├── scaffolds        // 模版文件</span><br><span class="line">├── source           // 源文件，用来存放你的文章 md 文件</span><br><span class="line">└── themes           // 主题文件</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以安装主题，比我我安装的 NexT 主题，安装完之后会在<code>themes</code> 下面产生一个 next文件存放主题中的内容，文档结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.en.md       // READEME 英文版</span><br><span class="line">├── README.md          // READEME 中文文件</span><br><span class="line">├── _config.yml        // 主题配置文件</span><br><span class="line">├── bower.json</span><br><span class="line">├── gulpfile.coffee</span><br><span class="line">├── languages         // 多语言配置文件</span><br><span class="line">├── layout            // 模板文件</span><br><span class="line">├── package.json      // 项目的依赖文件</span><br><span class="line">├── scripts           // 主题的脚本文件</span><br><span class="line">├── source            // 主题的资源文件 CSS IMG</span><br><span class="line">└── test</span><br></pre></td></tr></tbody></table></figure><h2 id="hexo-的工作原理">Hexo 的工作原理</h2><p>这里我们来分析一下 Hexo 每次部署的流程</p><ol type="1"><li>hexog：生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的<code>source</code> 文件夹（js、css、img等静态资源），然后建立索引，然后根据索引生成 <code>pubild</code>文件夹中，此时的 <code>publid</code> 文件是由 html、 js、css、img建立的纯静态文件可以通过 <code>index.html</code>作为入口访问你的博客。</li><li>hexo d：部署文件。部署主要是根据在 <code>_config.yml</code> 中配置的<code>git</code> 仓库或者 <code>coding</code> 的地址，将<code>public</code> 文件上传至 github 或者 coding 中。然后再根据上面的github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的<code>public</code> 文件上传至你自己的服务器上。</li></ol><h2 id="hexo-的模板引擎">Hexo 的模板引擎</h2><blockquote><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p></blockquote><p>我们可以注意到，在 Hexo 中，<code>source</code> 文件夹和<code>themes</code> 文件夹是在同级的，我们就可以将 <code>source</code>文件夹理解为数据库，而主题文件夹相当于 界面。然后我们<code>hexo g</code> 就将我们的数据和界面相结合生成静态文件<code>public</code>。</p><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md文件，然后根据 layout判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个html 页面。</p><p>模板文件在 <code>layout</code> 文件夹下，<code>layout</code>文件文档结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _custom                           // 通用布局</span><br><span class="line">├── _layout.swig                      // 默认布局布局</span><br><span class="line">├── _macro                            // 插件模板</span><br><span class="line">├── _partials                         // 局部布局</span><br><span class="line">├── _scripts                          // script模板</span><br><span class="line">├── _third-party                      // 第三方插件模板</span><br><span class="line">├── archive.swig                      // 归档模板</span><br><span class="line">├── category.swig                     // 分类模板</span><br><span class="line">├── index.swig                        // 首页模板</span><br><span class="line">├── page.swig                         // 其他模板</span><br><span class="line">├── photo.swig                        // 照片模板（自定义）</span><br><span class="line">├── post.swig                         // 文章模板</span><br><span class="line">├── schedule.swig                     // 归档模板</span><br><span class="line">└── tag.swig                          // 标签模板</span><br></pre></td></tr></tbody></table></figure><blockquote><p>每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局。</p></blockquote><p>在我们新建页面或者新建文章的使用可以选定我们使用的模板。<code>hexo new [layout] &lt;title&gt;</code>就会使用对应的模板。</p><p>其中 <code>_layout.swig</code> 是通用模板，里面引入了<code>head</code>、<code>footer</code>等公共组件，然后在其他的模板中会引入这个 <code>_layout.swig</code>通用模板，比如 <code>post.swig</code> 模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> {% extends '_layout.swig' %}</span><br><span class="line">{% import '_macro/post.swig' as post_template %}</span><br><span class="line">{% import '_macro/sidebar.swig' as sidebar_template %}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{% block title %} {{ page.title }} | {{ config.title }} {% endblock %}</span><br><span class="line"></span><br><span class="line">{% block page_class %}page-post-detail{% endblock %}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{% block content %}</span><br><span class="line"></span><br><span class="line">  &lt;div id="posts" class="posts-expand"&gt;</span><br><span class="line">    {{ post_template.render(page) }}</span><br><span class="line"></span><br><span class="line">    &lt;div class="post-spread"&gt;</span><br><span class="line">      {% if theme.jiathis %}</span><br><span class="line">        {% include '_partials/share/jiathis.swig' %}</span><br><span class="line">      {% elseif theme.baidushare %}</span><br><span class="line">        {% include '_partials/share/baidushare.swig' %}</span><br><span class="line">      {% elseif theme.add_this_id %}</span><br><span class="line">        {% include '_partials/share/add-this.swig' %}</span><br><span class="line">      {% elseif theme.duoshuo_shortname and theme.duoshuo_share %}</span><br><span class="line">        {% include '_partials/share/duoshuo_share.swig' %}</span><br><span class="line">      {% endif %}</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">{% endblock %}</span><br><span class="line"></span><br><span class="line">{% block sidebar %}</span><br><span class="line">  {{ sidebar_template.render(true) }}</span><br><span class="line">{% endblock %}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{% block script_extra %}</span><br><span class="line">  {% include '_scripts/pages/post-details.swig' %}</span><br><span class="line">{% endblock %}</span><br></pre></td></tr></tbody></table></figure><p>其中在第 11 行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{% block content %} </span><br><span class="line">    // 中间为该模板自定义内容</span><br><span class="line">{% endblock %}</span><br></pre></td></tr></tbody></table></figure><h2 id="数据的填充">数据的填充</h2><p>数据的填充主要是 <code>hexo -g</code> 的时候将数据传递给 swig模板，然后再由 swig 模板填充到 HTML 中。</p><h3 id="配置文件中的数据">配置文件中的数据</h3><p>Hexo 的配置文件 <code>_config.yml</code> 使用 <a href="https://link.juejin.cn?target=http%3A%2F%2Fdocs.ansible.com%2Fansible%2Flatest%2FYAMLSyntax.html">yml语法</a>。例如博客的名字、副标题等等之类。这些数据项组织在 config对象中。可以数字、字符串、对象、数组，</p><h3 id="配置文件中数据的使用">配置文件中数据的使用</h3><p>如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件swig 中直接使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% block title %} {{ page.title }} | {{ config.title }} {% endblock %}</span><br></pre></td></tr></tbody></table></figure><h3 id="hexo-中的变量">Hexo 中的变量</h3><p>Hexo 提供了很多的变量，比如我们上面使用的 <code>page</code>变量，还有 <code>site</code> 变量等，这些都是 Hexo提供的，我们可以拿来直接使用的，常用的变量有：</p><ul><li><pre><code>  site  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：对应整个网站的变量，一般会用到 </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>  site.posts.length</code></pre><p>制作分页器。</p><ul><li><code>site.posts</code> 所有文章</li><li><code>site.pages</code> 所有分页</li><li><code>site.categories</code> 所有分类</li><li><code>site.tags</code> 所有标签</li></ul></li><li><p><code>page</code>：存放当前页面的信息，例如我在<code>index.ejs</code> 中使用 <code>page.posts</code>获取了当前页面的所有文章而不是使用 <code>site.posts</code>。</p></li><li><p><code>config</code>：<code>config</code>变量我们在主目录下配置文件 <code>_config.yml</code>中保存的信息。</p></li><li><p><code>theme</code>：<code>theme</code>变量是我们在主题目录下配置文件 <code>_config.yml</code>中保存的信息。</p></li><li><p><code>path</code>：当前页面的路径（不含根路径）。</p></li><li><p><code>url</code>：页面完整网址。</p></li></ul><h4 id="页面变量">页面变量</h4><p>Page(page) 这里指的是 <code>hexo new page</code> 创建的那个页面</p><ul><li><code>page.title</code>：文章标题</li><li><code>page.date</code>：文章建立日期</li><li><code>page.updated</code>：文章更新日期</li><li><code>page.comments</code>：留言是否开启</li><li><code>page.layout</code>：布局名称</li><li><code>page.content</code>：文章完整内容</li><li><code>page.excerpt</code>：文章摘要</li><li><code>page.more</code>：除了摘要的其他内容</li><li><code>page.source</code>：文章原始路劲</li><li><code>page.full_source</code>：文章完整原始路径</li><li><code>page.path</code>：文章网址（不含根路径），通常在主题中使用url_for(page.path)</li><li><code>page.permalink</code>：文章永久网址</li><li><code>page.prev</code>：上一篇文章，如果此为第一篇文章则为null</li><li><code>page.next</code>：下一篇文章，如果此为最后一篇文章则为null</li><li><code>page.raw</code>：文章原始内容</li><li><code>page.photos</code>：文章的照片（用于相册）</li><li><code>page.link</code>：文章的外链（用于链接文章）</li></ul><h4 id="postpost-变量">Post(post) 变量</h4><p>这里指的是文章页面，与page布局相同，添加如下变量：</p><ul><li><code>page.pulished</code>：文章非草稿为true</li><li><code>page.categories</code>：文章分类</li><li><code>page.tags</code>：文章标签</li></ul><h4 id="首页index">首页(index)</h4><ul><li><code>page.per_page</code>：每一页显示的文章数</li><li><code>page.total</code>：文章数量</li><li><code>page.current</code>：当前页码</li><li><code>page.current_url</code>：当前页的URL</li><li><code>page.posts</code>：当前页的文章</li><li><code>page.prev</code>：前一页页码，如果为第一页，该值为0</li><li><code>page.prev_link</code>：前一页URL，如果为第一页，则为''</li><li><code>page.next</code>：后一页页码，如果为最后一页，则为0</li><li><code>page.next_link</code>：后一页URL，如果为最后一页，则为''</li><li><code>page.path</code>：当前页网址（不含根路径），通常在主题中使用url_for(page.path)</li></ul><h4 id="归档页archive">归档页(archive)</h4><p>与index布局相同，但是新增如下变量：</p><ul><li><code>archive</code> 为true</li><li><code>year</code> 归档年份（4位）</li><li><code>month</code> 归档月份（不包含0）</li></ul><h2 id="总结">总结</h2><p>非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的pages 服务）相结合，一键部署。</p><p>再深入一点讲 Hexo 的原理的话，那就应该是使用 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F07%2Fyaml.html%3Ff%3Dtt">yaml语言</a> 做配置文件，使用 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F16%2F0115%2F10%2F597197_528136785.shtml">ejs</a>或者 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Faix%2Flibrary%2Fau-swig%2F">swig</a>作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在B站通过up主程序羊了解到了Hexo，并且通过视频教程一步步搭建了个人博客，逞着兴趣正浓，网上看了许多关于Hexo的有关资料，对Hexo有了更多的了解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hexo的优缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo源码设计模式</title>
    <link href="https://maritimebyte.github.io/posts/eab89b12/"/>
    <id>https://maritimebyte.github.io/posts/eab89b12/</id>
    <published>2024-10-08T10:05:54.000Z</published>
    <updated>2024-10-08T12:06:44.104Z</updated>
    
    <content type="html"><![CDATA[<p>hexo是一个快速、简洁且高效的博客框架，实际上不仅仅如此，他是一个js语言的编写的静态网站生成器，主要作用是解析markdown语法，配合模版引擎，快速生成静态网站。同时可以自定义主题，引用第三方插件，除了搭建个人博客外，Hexo还被许许多多的项目拿来生成API文档。</p><h2 id="框架特色">框架特色</h2><p>Node.js运行环境，速度极快，扩展能力强，强大的插件系统，可配置性高，一件编译部署，适用于博客，静态个人网站，开源项目文档，最受欢迎的JS静态网站生成器。</p><blockquote><p>Tip: 本文所有代码均为伪代码</p></blockquote><h2 id="hexo命令行设计">Hexo命令行设计</h2><p>在命令行模块，Hexo选择使用miniist来解析命令行参数得到一个js对象，并建立一个Hexo实例对象call方法传递命令行指令。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title function_">minimist</span>(process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">var</span> cmd = args.<span class="property">_</span>.<span class="title function_">shift</span>()</span><br><span class="line"><span class="keyword">var</span> hexo = <span class="keyword">new</span> <span class="title class_">Hexo</span>()</span><br><span class="line">hexo.<span class="title function_">init</span>()</span><br><span class="line">hexo.<span class="title function_">call</span>(cmd, args)</span><br></pre></td></tr></tbody></table></figure><h2 id="hexo入口模块设计">Hexo入口模块设计</h2><p>同大多数框架相同，Hexo采用构造-原型组合模式定义类，采用组合继承的方式继承Node中EventEmitter模块，更容易通过<code>on</code>与<code>emit</code>发布和订阅事件。在实例化阶段，保存所编译文件存放路径、输出路径及其他脚步、插件、主题等所处路径，保存环境变量，即命令行参数、版本号等基本信息。创建扩展对象，按不同的功能进行分类，作用是创建store，用于注册句柄，获取句柄，以便后续编译过程调用，在Hexo中，扩展类型包括控制台（Console）、部署器（Deployer）、过滤器（Fitter）、生成器（Generator）、辅助函数（Helper）、处理器（Processer）、渲染引擎（Renderer）等等。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title function_">minimist</span>(process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">var</span> cmd = args.<span class="property">_</span>.<span class="title function_">shift</span>()</span><br><span class="line"><span class="keyword">var</span> hexo = <span class="keyword">new</span> <span class="title class_">Hexo</span>()</span><br><span class="line">hexo.<span class="title function_">init</span>()</span><br><span class="line">hexo.<span class="title function_">call</span>(cmd, args)</span><br></pre></td></tr></tbody></table></figure><h2 id="hexo编译模块设计">Hexo编译模块设计</h2><p>预期用户命令行接口</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>首先前往Hexo扩展对象Console中注册<code>generate</code>函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">register</span>(<span class="string">'generate'</span>, <span class="string">'Generate static files.'</span>, {</span><br><span class="line">  <span class="attr">options</span>: [</span><br><span class="line">    {<span class="attr">name</span>: <span class="string">'-d, --deploy'</span>, <span class="attr">desc</span>: <span class="string">'Deploy after generated'</span>},</span><br><span class="line">    {<span class="attr">name</span>: <span class="string">'-f, --force'</span>, <span class="attr">desc</span>: <span class="string">'Force regenerate'</span>},</span><br><span class="line">    {<span class="attr">name</span>: <span class="string">'-w, --watch'</span>, <span class="attr">desc</span>: <span class="string">'Watch file changes'</span>}</span><br><span class="line">  ]</span><br><span class="line">}, <span class="built_in">require</span>(<span class="string">'./generate'</span>));</span><br></pre></td></tr></tbody></table></figure><p><code>generate</code>函数用于生成目标文件夹，从Hexo的路由模块中取得所有需要生成目标文件的路径，调用<code>fs</code>输出文件，在此之前，首先对源文件进行预处理，把路径写入路由。由于Hexo本身设计的特点，源文件又分为内容和主题两部分，分别存放在source和theme文件夹，所以得调用<code>process</code>函数分别对它们进行预处理</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generate</span>(<span class="params">hexo</span>) {</span><br><span class="line">  hexo.<span class="property">source</span>.<span class="title function_">process</span>();</span><br><span class="line">  hexo.<span class="property">theme</span>.<span class="title function_">process</span>();</span><br><span class="line">  routerList.<span class="title function_">forEach</span>(<span class="function"><span class="params">path</span> =&gt;</span> <span class="title function_">writeFile</span>(path))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Hexo抽象出一层公用模块用来管理所有处理器，命名为Box，相当于一个容器，统一管理处理器的添加删除执行，监控，并分别为source和theme创建实例，Box原型如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Box</span>(<span class="params">base</span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">base</span> = base;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">processors</span> = [];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title class_">Box</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addProcessor</span> = <span class="keyword">function</span>(<span class="params">pattern, fn</span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">processors</span>.<span class="title function_">push</span>({</span><br><span class="line">    <span class="attr">pattern</span>: pattern,</span><br><span class="line">    <span class="attr">process</span>: fn</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="title class_">Box</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">process</span> = <span class="keyword">function</span>(<span class="params">callback</span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">processors</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">processor</span> =&gt;</span> processor.<span class="title function_">process</span>())</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>有了Box容器，接下来要做的就是往容器中添加处理器，同样，用插件的形式往扩展对象extend中注册句柄，在注入到Box容器中。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">hexo</span>) {</span><br><span class="line">  <span class="keyword">var</span> processor = hexo.<span class="property">extend</span>.<span class="property">processor</span>;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">require</span>(<span class="string">'./asset'</span>)(hexo);</span><br><span class="line">  processor.<span class="title function_">register</span>(obj.<span class="property">pattern</span>, obj.<span class="property">process</span>); <span class="comment">// pattern为文件名匹配格式</span></span><br><span class="line">  ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>以markdown文件处理为例，成功匹配到文件扩展名后，调用hexo-front-matter利用正则表达式匹配来解析文件，分离顶部元数据与主题内容，类似于<a href="https://github.com/jonschlinkert/gray-matter">gray-matter</a>，把元数据与内容以key/value的形式转化为一个js对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理器</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">hexo</span>) {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">pattern</span>: <span class="regexp">/\.md/</span>,</span><br><span class="line">    <span class="attr">process</span>: <span class="keyword">function</span>(<span class="params">path</span>) {</span><br><span class="line">      <span class="title function_">readFile</span>(path, <span class="keyword">function</span>(<span class="params">err, content</span>) {</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'hexo-front-matter'</span>)(content)</span><br><span class="line">        data.<span class="property">source</span> = path;</span><br><span class="line">        data.<span class="property">raw</span> = content;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      }</span><br><span class="line">    }  </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">// markdown文件</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">title: hello</span><br><span class="line"><span class="section">layout: home</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section"># Hexo</span></span><br><span class="line">A fast, simple &amp; powerful blog framework</span><br></pre></td></tr></tbody></table></figure><p>解析成 =&gt;</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">title</span>: <span class="string">'hello'</span>,</span><br><span class="line">  <span class="attr">layout</span>: <span class="string">'home'</span>,</span><br><span class="line">  <span class="attr">_content</span>: <span class="string">'# Hexo\nA fast, simple &amp; powerful blog framework'</span>,</span><br><span class="line">  <span class="attr">source</span>: <span class="string">'README.md'</span>,</span><br><span class="line">  <span class="attr">raw</span>: <span class="string">'---\ntitle: hello\n---\n# Hexo\nA fast, simple &amp; powerful blog framework'</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下一步，Hexo定义了过滤器(Fitter)的概念，借鉴于WordPress，用于在模版渲染前后修改具体的数据，也可以把它看成一个钩子，例如使用<a href="https://github.com/markedjs/marked">marked</a>编译markdown文件内容。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="title function_">execFilter</span>(<span class="string">'before_generate'</span>, <span class="keyword">function</span>(<span class="params">data</span>) {</span><br><span class="line">    hexo.<span class="property">render</span>.<span class="title function_">render</span>({</span><br><span class="line">      <span class="attr">text</span>: data.<span class="property">_content</span>,</span><br><span class="line">      <span class="attr">path</span>: data.<span class="property">source</span>,</span><br><span class="line">      <span class="attr">engine</span>: data.<span class="property">engine</span></span><br><span class="line">    });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>转化后增加一条content属性，带有标签与类名的markdown html片段</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  title<span class="punctuation">:</span> 'hello'<span class="punctuation">,</span></span><br><span class="line">  layout<span class="punctuation">:</span> 'home'<span class="punctuation">,</span></span><br><span class="line">  _content<span class="punctuation">:</span> '# Hexo\nA fast<span class="punctuation">,</span> simple &amp; powerful blog framework'<span class="punctuation">,</span></span><br><span class="line">  content<span class="punctuation">:</span> '&lt;h1 id=<span class="string">"Hexo"</span>&gt;&lt;a href=<span class="string">"#Hexo"</span> class=<span class="string">"headerlink"</span>     title=<span class="string">"Hexo"</span>&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;A fast<span class="punctuation">,</span> simple &amp; powerful blog   framework&lt;/p&gt;\n'<span class="punctuation">,</span></span><br><span class="line">  source<span class="punctuation">:</span> 'README.md'<span class="punctuation">,</span></span><br><span class="line">  raw<span class="punctuation">:</span> '---\ntitle<span class="punctuation">:</span> hello\n---\n# Hexo\nA fast<span class="punctuation">,</span> simple &amp; powerful blog framework' </span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>得倒页面数据后，进入模版引擎渲染阶段，Hexo本身不带模版引擎实现，需要借助第三方库，例如ejs，并通过一个适配器，把原接口转换为需求接口，向扩展对象extend.render中注册模版解析函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">'ejs'</span>, <span class="string">'html'</span>, <span class="keyword">function</span>(<span class="params">data, locals</span>) {</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'ejs'</span>).<span class="title function_">render</span>(data, locals))</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>模版引擎解析所有函数存储在hexo.theme对象中，以文件名作为key，后续渲染只需匹配layout就能找到指定的渲染函数，注入locals变量（上面markdown解析后的js对象+扩展对象extend.helper定义的变量、函数），生成最终文本字符串。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> view = hexo.<span class="property">theme</span>.<span class="title function_">getView</span>(data.<span class="property">layout</span>);</span><br><span class="line">view.<span class="title function_">render</span>(locals)</span><br></pre></td></tr></tbody></table></figure><p>最后通过Node<code>fs</code>模块把最终文本字符串输出到public目标文件夹中，大功告成。</p><p>回顾整个工作流程，可以看作</p><p>cli =&gt; hexo init =&gt; plugin load =&gt; process =&gt; filter=&gt; render =&gt; generate</p><h2 id="扩展阅读">扩展阅读</h2><p>Hexo有许多优秀设计模式</p><h3 id="数据库系统">数据库系统</h3><p>Hexo引入了json数据库<a href="https://github.com/hexojs/warehouse">warehouse</a>，也是作者自己开发的一个数据库驱动，API用法与Mongoose相差无几，在架构中的角色是充当一个中介者，存储临时数据，或者持久化数据存储，如博客的发表时间，还可以做完缓存层，比对文件的修改时间，跳过无修改文件的编译过程，减少二次编译的时间。</p><h3 id="异步方案">异步方案</h3><p>大量异步回调文件操作会让代码丧失可读性，Hexo引入Promise库<a href="https://github.com/petkaantonov/bluebird">blurebird</a>，内置丰富API，很方便的处理异步的流程控制，如使用<code>Promise.promisify(require('fs'),readFile)</code>可以把原生<code>fs</code>异步函数包装成一个Promise对象，另外，随着Node7.6正式版发布，直接支持async/await语法，可以更优雅得处理异步问题。</p><h3 id="通用日志模块">通用日志模块</h3><p>把Log划分为六个级别，'trace','debug','info','warn','error','fatal'，不同级别输出不同故事与颜色<a href="https://github.com/chalk/chalk">chalk</a>，并提供命令行接口，如果带有-debug字段，则Log自动降级为‘trace’级别</p><p>参考：<a href="https://juejin.cn/post/6844903469669679117" class="uri">https://juejin.cn/post/6844903469669679117</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo是一个快速、简洁且高效的博客框架，实际上不仅仅如此，他是一个js语言的编写的静态网站生成器，主要作用是解析markdown语法，配合模版引擎，快速生成静态网站。同时可以自定义主题，引用第三方插件，除了搭建个人博客外，Hexo还被许许多多的项目拿来生成API文档。&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>博客框架简介</title>
    <link href="https://maritimebyte.github.io/posts/539ce4a8/"/>
    <id>https://maritimebyte.github.io/posts/539ce4a8/</id>
    <published>2024-10-07T18:51:06.000Z</published>
    <updated>2024-10-15T15:44:48.259Z</updated>
    
    <content type="html"><![CDATA[<p>博客是以网络为载体，简易迅速便捷地发布自己的心得，及时有效地与他人进行交流，丰富多彩的个性化展示的综合性平台。</p><h2 id="博客搭建方式">博客搭建方式</h2><p>博客搭建方式可分为静态博客和动态博客。</p><p>静态博客：博文内容通过文档（如<code>.md</code>文件等）记录，通过工具编译成最终的html，css，js等动态文件，然后部署在静态server服务器或web托管至数据仓库（如：github），即可在互联网中被访问，不需要数据库支撑。</p><p>动态博客：以数据库技术为基础，博文内容通过数据库记录存储，主要特点体现在交互性；动不是指网页中页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登陆，评论，用户管理）</p><p>常见的博客框架</p><ul><li>静态框架<ul><li><a href="https://hexo.io/zh-cn/">Hexo</a></li><li><a href="https://www.gohugo.cn/">Hugo</a></li><li><a href="https://www.vuepress.cn/">VuePress</a></li><li><a href="https://www.jekyll.com.cn/">jekyll</a></li></ul></li><li>动态框架<ul><li><a href="https://wordpress.org/">WordPress</a></li><li><a href="https://typecho.org/">Typecho</a></li><li><a href="https://www.halo.run/">Halo</a></li><li><a href="https://b3log.org/solo/">Solo</a></li></ul></li></ul><h2 id="框架简介">框架简介</h2><h3 id="hexo">Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="hugo">Hugo</h3><p>Hugo 是一个快速且现代的静态网站生成器，采用 Go 编程语言开发，Hugo的设计目标是让创建网站重新变得有趣。</p><p>Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个<a href="https://www.gohugo.cn/about/benefits/">静态站点生成器</a>。与动态构建页面的系统不同，Hugo在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。</p><p>使用 Hugo 构建的网站非常快速和安全。Hugo构建的网站可以托管在任何地方，包括 <a href="https://netlify.com/">Netlify</a>、<a href="https://www.heroku.com/">Heroku</a>、<a href="https://www.godaddy.com/">GoDaddy</a>、<a href="https://www.dreamhost.com/">DreamHost</a>、<a href="https://pages.github.com/">GitHub Pages</a>、<a href="https://about.gitlab.com/features/pages/">GitLab Pages</a>、<a href="https://surge.sh/">Surge</a>、<a href="https://www.aerobatic.com/">Aerobatic</a>、<a href="https://firebase.google.com/docs/hosting/">Firebase</a>、<a href="https://cloud.google.com/storage/">Google Cloud Storage</a>、<a href="https://aws.amazon.com/s3/">Amazon S3</a>、<a href="https://www.rackspace.com/cloud/files">Rackspace</a>、<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure</a>,和 <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>，并且与CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP等昂贵的运行时环境。</p><p>Hugo是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。</p><h3 id="vuepress">VuePress</h3><p>VuePress 由两部分组成：第一部分是一个<a href="https://github.com/vuejs/vuepress/tree/master/packages/@vuepress/core">极简静态网站生成器(opens new window)</a>，它包含由 Vue 驱动的<a href="https://www.vuepress.cn/theme/">主题系统</a>和<a href="https://www.vuepress.cn/plugin/">插件API</a>，另一个部分是为书写技术文档而优化的<a href="https://www.vuepress.cn/theme/default-theme-config.html">默认主题</a>，它的诞生初衷是为了支持Vue 及其子项目的文档需求。</p><p>每一个由 VuePress 生成的页面都带有预渲染好的HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。</p><p>事实上，一个 VuePress 网站是一个由 <a href="http://vuejs.org/">Vue(opens new window)</a>、<a href="https://github.com/vuejs/vue-router">Vue Router (opens newwindow)</a>和 <a href="http://webpack.js.org/">webpack (opens newwindow)</a>驱动的单页应用。如果你以前使用过 Vue的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用Vue DevTools 去调试你的自定义主题。</p><p>在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于<a href="https://nuxtjs.org/">Nuxt (opens new window)</a>的<code>nuxt generate</code> 命令，以及其他的一些项目，比如 <a href="https://www.gatsbyjs.org/">Gatsby (opens new window)</a>。</p><h3 id="jekyll">Jekyll</h3><p>Jekyll 是一个静态网站生成器。用你喜欢的 标记语言书写内容并交给 Jekyll处理，它将利用模板为你创建一个静态网站。你可以调整你想要的网址样式、在网站上显示哪些数据 等等。</p><h3 id="wordpress">WordPress</h3><p>WordPress 于 2003年发布，时至今日仍是非常受欢迎的开源内容管理平台，用于创建网站、博客网站甚至应用。事实上，大约 30% 的网页是使用 WordPress 创建的。</p><p>WordPress 为内容创建者和 IT 管理员提供了几大优势。 例如，WordPress提供了高度的灵活性，无需进行大量的设计或开发工作。 使用和管理也很简单。重要的是，WordPress支持多种部署方案，因此您可以根据自己的架构偏好将此平台集成到自己的环境中。</p><h3 id="typecho">Typecho</h3><p><strong>Typecho</strong>是一个基于<a href="https://zh.wikipedia.org/wiki/PHP">PHP</a>的开源博客程序。它使用多种数据库（<a href="https://zh.wikipedia.org/wiki/MySQL">MySQL</a>、<a href="https://zh.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a>、<a href="https://zh.wikipedia.org/wiki/SQLite">SQLite</a>、<a href="https://zh.wikipedia.org/wiki/MariaDB">MariaDB</a>）储存数据，在<a href="https://zh.wikipedia.org/wiki/GNU通用公共许可协议">GPLv2</a>许可证下发行。</p><h3 id="halo">Halo</h3><p>Halo基于Java语言，使用<a href="">springboot</a>框架开发的博客系统，致力于打造最好的java博客系统，且只想安安静静等做一个博客系统。</p><h3 id="solo">Solo</h3><p>solo基于Java有后台的，小而美的博客系统，专为程序员设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客是以网络为载体，简易迅速便捷地发布自己的心得，及时有效地与他人进行交流，丰富多彩的个性化展示的综合性平台。&lt;/p&gt;
&lt;h2 id=&quot;博客搭建方式&quot;&gt;博客搭建方式&lt;/h2&gt;
&lt;p&gt;博客搭建方式可分为静态博客和动态博客。&lt;/p&gt;
&lt;p&gt;静态博客：博文内容通过文档（如&lt;cod</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo忽略一些无需编译的文件</title>
    <link href="https://maritimebyte.github.io/posts/a680fc83/"/>
    <id>https://maritimebyte.github.io/posts/a680fc83/</id>
    <published>2024-10-07T18:20:13.000Z</published>
    <updated>2024-10-07T21:59:58.547Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo中如果需要自定义自己喜欢的主题或者页面，hexo默认编译source目录下的所有文件。</p><p>下面主要分享一个实用的技术点：自定义无需编译的文件</p><h2 id="方法">方法</h2><p>修改<code>_config.yml</code>中的一个配置项<code>skip_render</code></p><blockquote><p>Skip_render：跳过指定文件的渲染，可用glob表达式匹配路径</p></blockquote><h2 id="配置">配置</h2><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过单个文件</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">test.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过所有的html的文件</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">'*.html'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过某一目录下的所有文件:</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">test/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要跳过某一目录下的所有文件和子目录时：</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">test/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过多个目录，或者多个文件：</span></span><br><span class="line"><span class="attr">skip_render:</span> [<span class="string">'*.html'</span>, <span class="string">demo/**</span>, <span class="string">test/*</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以配置成多行</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test1/*.html</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test2/**</span></span><br></pre></td></tr></tbody></table></figure><h2 id="错误">错误</h2><ol type="1"><li>设置<code>skip_render</code>不起作用，执行<code>hexo clean</code>清楚缓存。</li><li>跳过多个目录编译失败，尝试更新<code>hexo</code>，在source同级目录中执行<code>npm update hexo</code></li><li>如果需要查看是否成功跳过编译，可以在编译时加上<code>--debug</code>例如：<code>hexo generate --debug</code>，关注输出<code>Rendering xxxx</code>中的东西。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo中如果需要自定义自己喜欢的主题或者页面，hexo默认编译source目录下的所有文件。&lt;/p&gt;
&lt;p&gt;下面主要分享一个实用的技术点：自定义无需编译的文件&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;p&gt;修改&lt;code&gt;_config.yml&lt;/code&gt;中的一</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo建立一个独立HTML页面</title>
    <link href="https://maritimebyte.github.io/posts/233e464c/"/>
    <id>https://maritimebyte.github.io/posts/233e464c/</id>
    <published>2024-10-06T13:57:40.000Z</published>
    <updated>2024-10-09T04:29:57.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>Hexo作为一个轻量、强大的博客框架，当我们需要发布博文，只需将markdown文件放入<code>blogRoot/source/_posts</code>目录下，再执行<code>hexo g</code>命令时，<code>.md</code>文件便能转化为html文件，但是有时候我们并不想Hexo渲染我们的自己独立的样式，比如放入一些自己的作品和相册等...</p><h2 id="方法一">方法一</h2><p>使用Hexo提供的跳过渲染配置，在Hexo配置文件下<code>_config.yml</code>找到<code>skip_render</code>关键字，在后面添加跳过渲染的页面，比如我们创建的<code>/source/about/index.html</code>，配置文件填写<code>skip_render: about/**</code>，那么就表示<code>/source/about</code>所有文件将跳过渲染，里面的文件将会被直接复制到public文件夹中，此时可以得到一个独立的about页面</p><h2 id="方法二">方法二</h2><p>在文章头部的<code>front-matter</code>里添加配置<code>layout: false</code>来跳过渲染配置，比如我们要使用<code>about</code>页面跳过渲染，创建<code>/source/about/index.md</code>，将这个页面的相关<code>html</code>代码写入<code>.md</code>文件并保存，然后再<code>index.md</code>的头部添加如下设置：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">layout: false</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">{% raw %}</span><br><span class="line">xxxxxxxxxxxxx</span><br><span class="line">xx HTML代码 xx</span><br><span class="line">xxxxxxxxxxxxx</span><br><span class="line">{% endraw %}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Front-matter是<code>.md</code>文件以---分割的区域，用于指定个别文件变量</p><p><code>.md</code>文件中的<code>html</code>代码要用<code>`和`</code>包起来，使其正确编译里面的代码</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;Hexo作为一个轻量、强大的博客框架，当我们需要发布博文，只需将markdown文件放入&lt;code&gt;blogRoot/source/_posts&lt;/code&gt;目录下，再执行&lt;code&gt;hexo g&lt;/code&gt;命令时，&lt;code&gt;.m</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
    <category term="html" scheme="https://maritimebyte.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章锚点</title>
    <link href="https://maritimebyte.github.io/posts/9c47cdff/"/>
    <id>https://maritimebyte.github.io/posts/9c47cdff/</id>
    <published>2024-10-06T13:20:05.000Z</published>
    <updated>2024-10-06T14:16:08.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当前文章锚点跳转">当前文章锚点跳转</h2><blockquote><ol type="1"><li>使用markdown生成目录</li><li>使用html<code>&lt;span id="jump"&gt;跳转的地方&lt;/span&gt;span&gt;</code>，然后使用<code>[点击跳转](#jump)</code></li></ol></blockquote><h2 id="站内文章链接">站内文章链接</h2><p>官方有标签插件实现，如下：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post<span class="emphasis">_link官方文档{% post_</span>link 'hexo blog' %}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tip:优先使用文章<code>Front-matter</code>中的<code>permalink</code>，如果没有<code>permalink</code>，则使用<strong>文件名字</strong>！</p></blockquote><h2 id="站内其他文章锚点链接">站内其他文章锚点链接</h2><p>上面的<code>post_link</code>在链接站内其他文章时很好用，但是不支持站内其他文章的锚点链接。</p><p>官方文档还有一个<code>post_path</code>，用于获取文章路径，结合markdown内置链接方式，即可实现站内其他文章锚点链接</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post<span class="emphasis">_path官方文档[<span class="string">hexo 安装</span>](<span class="link">{% post_path 'hexo blog' %}#安装</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>也可使用<code>html &lt;a&gt;</code>标签实现，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="{% post_path 'hexo blog' %}#安装"&gt;hexo 安装&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tip:</p><ol type="1"><li>如果文章内有图片，可能出现锚点位置不准确的问题，原因是图片加载好把文字内容撑开</li><li>如果有空格，需要把空格换成连字符-。</li></ol></blockquote><h2 id="站外文章锚点超链接">站外文章锚点（超链接）</h2><p>直接使用全局路径即可，如下：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hexo 引用文章</span>](<span class="link">https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tip: 要设置anchors</p></blockquote><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  anchors:</span><br><span class="line"><span class="code">    # Minimum level for ID creation. (Ex. h2 to h6)</span></span><br><span class="line"><span class="code">    level: 2</span></span><br><span class="line"><span class="code">    # A suffix that is prepended to the number given if the ID is repeated.</span></span><br><span class="line"><span class="code">    collisionSuffix: ''</span></span><br><span class="line"><span class="code">    # If `true`, creates an anchor tag with a permalink besides the heading.</span></span><br><span class="line"><span class="code">    permalink: true</span></span><br><span class="line"><span class="code">    # Class used for the permalink anchor tag.</span></span><br><span class="line"><span class="code">    permalinkClass: header-anchor</span></span><br><span class="line"><span class="code">    # Set to 'right' to add permalink after heading</span></span><br><span class="line"><span class="code">    permalinkSide: 'right'</span></span><br><span class="line"><span class="code">    # The symbol used to make the permalink</span></span><br><span class="line"><span class="code">    permalinkSymbol: ⁍</span></span><br><span class="line"><span class="code">    # Transform anchor to (1) lower case; (2) upper case</span></span><br><span class="line"><span class="code">    case: 1</span></span><br><span class="line"><span class="code">    # Replace space with a character</span></span><br><span class="line"><span class="code">    separator: '-'</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;当前文章锚点跳转&quot;&gt;当前文章锚点跳转&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;使用markdown生成目录&lt;/li&gt;
&lt;li&gt;使用html&lt;code&gt;&amp;lt;span id=&quot;jump&quot;&amp;gt;跳转的地方&amp;lt;/span&amp;gt;s</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法补充</title>
    <link href="https://maritimebyte.github.io/posts/df4516cb/"/>
    <id>https://maritimebyte.github.io/posts/df4516cb/</id>
    <published>2024-10-06T12:30:49.000Z</published>
    <updated>2024-10-06T14:16:08.011Z</updated>
    
    <content type="html"><![CDATA[<p>在hexo中使用markdown是简单、容易的，markdown语法的简洁可以让我们得到一个干净简洁的版面，但简单</p><p>的同时也意味着某些功能的缺失，比如插入音频和视频，实现文字居中等，好在Hexo框架中等博客是将markdown文件先渲染为html文件，所以在markdown文件中写入html语法也能被Hexo正常显示渲染，以下为个人在写博客中有用到的一些html标签，方便站内查找</p><h2 id="字体字号和颜色">字体字号和颜色</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">6</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff size=6 face="黑体"<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">6</span>&gt;</span>color=#00ffff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">6</span>&gt;</span>color=gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><font face="黑体">我是黑体字</font><font face="微软雅黑">我是微软雅黑</font><font face="STCAIYUN">我是华文彩云</font><font color="#0099ff" size="6" face="黑体">color=#0099ff size=6face="黑体"</font> <font color="#00ffff" size="6">color=#00ffff</font><font color="gray" size="6">color=gray</font></p><blockquote><p>Size:规定了文本尺寸大小，范围1～7，默认为3。颜色为十六进制RGB</p></blockquote><h2 id="图片居中及改变大小">图片居中及改变大小</h2><p>居中：<code>&lt;div alighn=center&gt;</code></p><p>改变图片大小：<code>&lt;img src="图片路径" width="300" height="200" alt="图片" &gt;</code></p><blockquote><p>改变图片大小可能导致图片变形</p></blockquote><h2 id="代办事宜">代办事宜</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> [x] 男</span><br><span class="line"><span class="bullet">*</span> [ ] 女</span><br></pre></td></tr></tbody></table></figure><p>显示效果：</p><ul class="task-list"><li><label><input type="checkbox" checked="">男</label></li><li><label><input type="checkbox">女</label></li></ul><h2 id="页面内跳转">页面内跳转</h2><p>使用heml代码实现。</p><p>在要跳转位置定义一个锚点<code>&lt;span id="jump"&gt;target&lt;/span&gt;</code></p><p>使用<code>[target](#jump)</code>将<code>target</code>设置为一点击就跳转到锚点所在位置</p><p><a href="#jump">target</a></p><p><span id="jump">target</span></p><h2 id="行内缩进">行内缩进</h2><p>半方大的空白<code>&amp;ensp</code>或<code>&amp;#8194</code></p><p>全方大的空白<code>&amp;emsp</code>或<code>&amp;#8195</code></p><p>不断行的空白<code>&amp;nbsp</code>或<code>&amp;#160</code></p><p>间距如下：</p><p> AAA</p><p> AAA</p><p>&nbsp;AAA</p><h2 id="视频嵌套">视频嵌套</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">controls</span>=<span class="string">""</span> <span class="attr">preload</span>=<span class="string">"none"</span> <span class="attr">poster</span>=<span class="string">"http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.jpg"</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">"mp4"</span> <span class="attr">src</span>=<span class="string">"http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><video id="video" controls="" preload="none" poster="http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.jpg"><source id="mp4" src="http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.mp4" type="video/mp4"></video><h2 id="音频嵌套">音频嵌套</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">"audio"</span> <span class="attr">controls</span>=<span class="string">""</span> <span class="attr">preload</span>=<span class="string">"none"</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">"mp3"</span> <span class="attr">src</span>=<span class="string">"http://oht4nlntk.bkt.clouddn.com/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><audio id="audio" controls="" preload="none"><source id="mp3" src="http://oht4nlntk.bkt.clouddn.com/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3"></audio><h2 id="总结">总结</h2><p>以上markdown结合html的语法不常用，在有需求时在查阅即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在hexo中使用markdown是简单、容易的，markdown语法的简洁可以让我们得到一个干净简洁的版面，但简单&lt;/p&gt;
&lt;p&gt;的同时也意味着某些功能的缺失，比如插入音频和视频，实现文字居中等，好在Hexo框架中等博客是将markdown文件先渲染为html文件，所以在m</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="markdown" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/markdown/"/>
    
    
    <category term="html" scheme="https://maritimebyte.github.io/tags/html/"/>
    
    <category term="markdown" scheme="https://maritimebyte.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly添加全局吸底Aplayer</title>
    <link href="https://maritimebyte.github.io/posts/c9e95d91/"/>
    <id>https://maritimebyte.github.io/posts/c9e95d91/</id>
    <published>2024-10-05T17:59:15.000Z</published>
    <updated>2024-10-05T18:41:19.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>要使用 aplayer，需要安裝 <a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a>。这款插件通过 Hexo独有的标签外挂，可以很方便的写入一些参数，插件就会帮我们生成对应的html。如果你只是使用一些简单的功能，其实无需使用到这个插件，只需以 html格式书写就行，不用插件去转换。</p><p>例如：</p><p>如果使用插件，在 markdown 中这样写：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% meting "000PeZCQ1i4XVs" "tencent" "artist" "theme:#3F51B5" "mutex:true" "preload:auto" %}</span><br></pre></td></tr></tbody></table></figure><p>其会被插件渲染为:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer-uxAIfEUs"</span> <span class="attr">class</span>=<span class="string">"aplayer aplayer-tag-marker meting-tag-marker"</span> <span class="attr">data-id</span>=<span class="string">"000PeZCQ1i4XVs"</span> <span class="attr">data-server</span>=<span class="string">"tencent"</span> <span class="attr">data-type</span>=<span class="string">"artist"</span> <span class="attr">data-mode</span>=<span class="string">"circulation"</span> <span class="attr">data-autoplay</span>=<span class="string">"false"</span> <span class="attr">data-mutex</span>=<span class="string">"true"</span> <span class="attr">data-listmaxheight</span>=<span class="string">"340px"</span> <span class="attr">data-preload</span>=<span class="string">"auto"</span> <span class="attr">data-theme</span>=<span class="string">"#3F51B5"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>如果不想使用插件，就需要在markdown中用html的格式书写，同时把主题配置文件中的<code>aplayer Inject</code>开启</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer"</span> <span class="attr">data-id</span>=<span class="string">"000PeZCQ1i4XVs"</span> <span class="attr">data-server</span>=<span class="string">"tencent"</span> <span class="attr">data-type</span>=<span class="string">"artist"</span> <span class="attr">data-mutex</span>=<span class="string">"true"</span> <span class="attr">data-preload</span>=<span class="string">"auto"</span> <span class="attr">data-theme</span>=<span class="string">"#3F51B5"</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>回到正题，如何在Butterfly上使用全局吸底 Aplayer</p><h2 id="关闭asset_inject">关闭<code>asset_inject</code></h2><blockquote><p>此步骤适用于安装了<code>hexo-tag-aplayer</code>插件的人</p></blockquote><p>由于需要全局都插入 aplayer 和 meting资源，为了防止插入重复的资源，需要把 <code>asset_inject</code>设为false</p><p>在 Hexo 的配置文件中</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h2 id="插入-aplayer-html">插入 Aplayer html</h2><p>为了适配 hexo-tag-aplayer，主题内置的 Meting js 仍为 1.2版本，并非最新的 2.x 版本。</p><p>Aplayer html 例子：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer no-destroy"</span> <span class="attr">data-id</span>=<span class="string">"60198"</span> <span class="attr">data-server</span>=<span class="string">"netease"</span> <span class="attr">data-type</span>=<span class="string">"playlist"</span> <span class="attr">data-fixed</span>=<span class="string">"true"</span> <span class="attr">data-autoplay</span>=<span class="string">"true"</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>参数解释：</p><table><colgroup><col style="width: 17%"><col style="width: 9%"><col style="width: 72%"></colgroup><thead><tr><th>option</th><th>default</th><th>description</th></tr></thead><tbody><tr><td>data-id</td><td>require</td><td>song id / playlist id / album id / search keyword</td></tr><tr><td>data-server</td><td>require</td><td>music platform: netease, tencent, kugou, xiami, baidu</td></tr><tr><td>data-type</td><td>require</td><td>song, playlist, album, search, artist</td></tr><tr><td>data-fixed</td><td>false</td><td>enable fixed mode</td></tr><tr><td>data-mini</td><td>false</td><td>enable mini mode</td></tr><tr><td>data-autoplay</td><td>false</td><td>audio autoplay</td></tr><tr><td>data-theme</td><td>#2980b9</td><td>main color</td></tr><tr><td>data-loop</td><td>all</td><td>player loop play, values: 'all', 'one', 'none'</td></tr><tr><td>data-order</td><td>list</td><td>player play order, values: 'list', 'random'</td></tr><tr><td>data-preload</td><td>auto</td><td>values: 'none', 'metadata', 'auto'</td></tr><tr><td>data-volume</td><td>0.7</td><td>default volume, notice that player will remember user setting,default volume will not work after user set volume themselves</td></tr><tr><td>data-mutex</td><td>true</td><td>prevent to play multiple player at the same time, pause otherplayers when this player start play</td></tr><tr><td>data-lrctype</td><td>0</td><td>lyric type</td></tr><tr><td>data-listfolded</td><td>false</td><td>indicate whether list should folded at first</td></tr><tr><td>data-listmaxheight</td><td>340px</td><td>list max height</td></tr><tr><td>data-storagename</td><td>metingjs</td><td>localStorage key that store player setting</td></tr></tbody></table><blockquote><p>require代表着这些参数是必须要使用的，其它的参数则可以根据自己需要配置。</p><p>配置全局吸底，data-fixed 和 data-mini 也必须配置，配置为 true</p><p>如果使用 Pjax，则在 class 裏需添加 no-destroy，这样防止切换页面时Aplayer 被销毁</p></blockquote><p>把 aplayer代碼 插入到主題配置文件的 inject.bottom 去</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class="aplayer</span> <span class="literal">no</span><span class="string">-destroy"</span> <span class="string">data-id="60198"</span> <span class="string">data-server="netease"</span> <span class="string">data-type="playlist"</span> <span class="string">data-fixed="true"</span> <span class="string">data-autoplay="true"&gt;</span> <span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>运行 Hexo 就可以看到网页左下角出现了 Aplayer</p><p>最后，如果你想切换页面时，音乐不会中断。请把主题配置文件的 pjax 设为true</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;要使用 aplayer，需要安裝 &lt;a href=&quot;https://github.com/MoePlayer/hexo-tag-aplayer&quot;&gt;hexo-tag-aplayer&lt;/a&gt;
。这款插件通过 Hexo
独有的标签外挂，可以</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="butterfly" scheme="https://maritimebyte.github.io/tags/butterfly/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo完美支持数学公式</title>
    <link href="https://maritimebyte.github.io/posts/c14cd9b1/"/>
    <id>https://maritimebyte.github.io/posts/c14cd9b1/</id>
    <published>2024-10-05T16:38:40.000Z</published>
    <updated>2024-10-05T16:51:01.787Z</updated>
    
    <content type="html"><![CDATA[<p>按照网上的攻略尝试了几种方法，卸载了Hexo默认渲染插件<code>hexo-renderer-marked</code></p><p>更换了markdown渲染器依旧不能完美显示数学公式</p><p>最终是通过一个大佬的博客，他使用的主题是 NexT 8.10使用了 <a href="https://pandoc.org/installing.html">pandoc</a>来显示数学公式，能够完美支持</p><p>按照他的方法，在Butterfly主题下也安装了pandoc渲染插件<code>hexo-renderer-pandoc</code>发现原来不能显示的数学公式能够完美显示了😆</p><h2 id="安装-hexo-renderer-pandoc">安装 hexo-renderer-pandoc</h2><p>为了使用 pandoc 作为 Hexo 的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载Hexo默认渲染插件：</span></span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装pandoc渲染插件：</span></span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></tbody></table></figure><h2 id="配置使用-mathjax">配置使用 mathjax</h2><p>在站点 NexT 配置文件 _config.yml 文件中添加如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Next v6.3.0 后的版本 tags 要设置成 ams</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">ams</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安装-pandoc-软件包">安装 pandoc 软件包</h2><p>从 <a href="https://pandoc.org/installing.html">pandoc</a>官网下载所需要的软件包，我这里使用的 Windows10 + GitBash方式，因此我下载了 Windows 安装包， 安装完毕后，记得重新打开 GitBash命令框 ，不然执行 <strong>Hexo g</strong> 会报错。</p><p>完成后，执行命令，既可以完美显示公式了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按照网上的攻略尝试了几种方法，卸载了Hexo默认渲染插件&lt;code&gt;hexo-renderer-marked&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更换了markdown渲染器依旧不能完美显示数学公式&lt;/p&gt;
&lt;p&gt;最终是通过一个大佬的博客，他使用的主题是 NexT 8.10使用了 </summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo的Butterfly主题中添加本地搜索功能</title>
    <link href="https://maritimebyte.github.io/posts/2a319798/"/>
    <id>https://maritimebyte.github.io/posts/2a319798/</id>
    <published>2024-10-05T15:15:29.000Z</published>
    <updated>2024-10-09T04:29:13.818Z</updated>
    
    <content type="html"><![CDATA[<p>在butterfly官网上有三个插件可供选择，分别是Algolia search，Localsearch， Docsearch</p><p>Algoliasearch借助第三方网站algolia，需要在algolia注册账号，并需要执行命令把自己网站的信息上传到algolia，每次搜索都需要请求algolia的数据，网络较慢会导致网址打开速度降低</p><p>Localsearch依靠hexo-generator-search插件是把文章的信息生成一个搜索库放在本地，所以搜索效率很高。</p><p><a href="https://docsearch.algolia.com/?utm_source=artical_gitcode">DocSearch</a>是一款由 Algolia公司提供的专业文档搜索引擎，旨在帮助开发者和内容创作者构建强大、精准且用户体验极佳的文档搜索功能。这款开源工具通过集成先进的搜索算法，使用户能够轻松地在大量技术文档中找到所需信息。</p><p>本文仅针对Local search进行配置</p><h2 id="安装hexo-generator-search插件">安装hexo-generator-search插件：</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></tbody></table></figure><h2 id="配置插件">配置插件：</h2><p><del>### 配置_config.yml，添加以下内容</del></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></tbody></table></figure><p><del>其中，path为生成的搜索文件名，field指定搜索的对象（可以是post或page），format指定搜索结果的格式，limit指定最多显示的搜索结果数量。</del></p><h3 id="配置_config.butterfly.yml修改以下内容">配置_config.butterfly.yml修改以下内容</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></tbody></table></figure><h2 id="生成搜索文件">生成搜索文件：</h2><p>在Hexo博客目录下，运行以下命令生成搜索文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></tbody></table></figure><p>完成以上步骤后，Hexo博客就可以使用站内搜索功能了。在博客中输入关键字进行搜索，并查看搜索结果页面。</p><p>需要注意的是插件官网的配置中有个template配置，无需配置该项。配置了反而无法正常搜索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在butterfly官网上有三个插件可供选择，分别是Algolia search，Local
search， Docsearch&lt;/p&gt;
&lt;p&gt;Algolia
search借助第三方网站algolia，需要在algolia注册账号，并需要执行命令把自己网站的信息上传到alg</summary>
      
    
    
    
    <category term="前端" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/categories/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
    <category term="butterfly" scheme="https://maritimebyte.github.io/tags/butterfly/"/>
    
    <category term="hexo" scheme="https://maritimebyte.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
